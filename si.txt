import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.Map;

public class PlanoTransformer {

    // Ruta quemada donde se deja la copia (ajústala si la quieres en otra ubicación)
    private static final String OUTPUT_PATH = "C:\\temp\\plano_modificado_RC.txt";

    /**
     * Modifica el primer registro (primera línea) del archivo plano siguiendo las reglas que
     * el usuario especificó y escribe el archivo modificado en OUTPUT_PATH.
     *
     * Parámetros esperados en `params`:
     *  - "numeroIDEmpresa"      -> valor que viene de getParameter(FLUJO_KEYS[1]) (DV incluido, sin guion)
     *  - "servicio"             -> valor que viene de getParameter(FLUJO_KEYS[3]) ("Nomina"/"Pago a Proveedores")
     *  - "tipProductoOrigen"    -> valor que viene de getParameter(FLUJO_KEYS[4]) ("Cuenta de ahorros" / "Cuenta corriente")
     *  - "numeroProductoOrigen" -> valor que viene de getParameter(FLUJO_KEYS[5]) (número de cuenta)
     *
     * @param inputFile archivo plano original
     * @param params mapa con parámetros mencionados arriba
     * @return ruta absoluta del archivo generado (OUTPUT_PATH)
     * @throws IOException en errores IO
     * @throws IllegalArgumentException en caso de que el archivo no contenga los campos obligatorios a validar
     */
    public static String transformFirstRecord(File inputFile, Map<String, String> params) throws IOException {
        if (inputFile == null || !inputFile.exists()) {
            throw new IllegalArgumentException("Archivo de entrada no existe.");
        }

        // Leer todas las líneas (preservamos las demás sin tocar)
        Path inputPath = inputFile.toPath();
        java.util.List<String> lines = Files.readAllLines(inputPath, StandardCharsets.UTF_8);

        if (lines.isEmpty()) {
            throw new IllegalArgumentException("Archivo vacío.");
        }

        String original = lines.get(0);

        // Nos aseguramos al menos longitud 170 para trabajar; si es más corto, lo completamos temporalmente con espacios
        int minLen = 170;
        StringBuilder originalPadded = new StringBuilder(original);
        if (originalPadded.length() < minLen) {
            while (originalPadded.length() < minLen) originalPadded.append(' ');
        }
        String o = originalPadded.toString(); // uso para extraer campos inmutables

        // --- Extraer campos que deben conservarse desde el original (validar existencia) ---
        if (o.length() < 50) { // necesitamos al menos hasta posición 50 para validar banco
            throw new IllegalArgumentException("Registro original demasiado corto para validar campos obligatorios (necesita al menos 50 caracteres).");
        }
        String codigoBancoOriginal = safeSubstring(o, 44, 50); // posiciones 45-50 (1-based)
        if (codigoBancoOriginal.trim().isEmpty()) {
            throw new IllegalArgumentException("Código de banco (pos.45-50) no existe en el archivo original.");
        }

        // Campos a preservar (del original)
        String valorTotalOriginal = safeSubstring(o, 50, 68);   // pos 51-68
        String numeroTotalOriginal = safeSubstring(o, 68, 74);  // pos 69-74
        String fechaProcesoOriginal = safeSubstring(o, 74, 82);// pos 75-82
        String horaProcesoOriginal = safeSubstring(o, 82, 88); // pos 83-88

        // --- Preparar nuevos valores según parámetros ---
        String nit = cleanAndPadLeft(params.get("numeroIDEmpresa"), 16); // pos 3-18
        String servicioParam = params.getOrDefault("servicio", "").toLowerCase();
        String servicioFull8;
        if (servicioParam.contains("nomina") || servicioParam.contains("nómina")) {
            servicioFull8 = "NOMINOMI"; // cubre pos 19-26 (servicio + subservicio)
        } else {
            // por defecto tratamos como Pago a Proveedores
            servicioFull8 = "PROVPROV";
        }
        String numeroProducto = cleanAndPadLeft(params.get("numeroProductoOrigen"), 16); // pos 27-42

        String tipProd = params.getOrDefault("tipProductoOrigen", "").toLowerCase();
        String tipoCuenta;
        if (tipProd.contains("ahorr")) {
            tipoCuenta = "CA"; // Cuenta de Ahorros
        } else if (tipProd.contains("corr") || tipProd.contains("corrient")) {
            tipoCuenta = "CC"; // Cuenta Corriente
        } else {
            // Si no se reconoce, por defecto CA (puedes cambiar esta lógica)
            tipoCuenta = "CA";
        }

        // Campos a completar con ceros o constantes según la descripción
        String codigoOperador = repeatChar('0', 4);      // pos 89-92
        String codigoNoProcesado = "9999";              // pos 93-96
        String fechaGeneracion = repeatChar('0', 8);     // pos 97-104
        String horaGeneracion = repeatChar('0', 6);      // pos 105-110
        String indicadorInscripcion = repeatChar('0', 2);// pos 111-112
        String tipoIdentificacion = "03";                // pos 113-114
        String numClienteDav = repeatChar('0', 12);      // pos 115-126
        String codOficinaRecaudo = repeatChar('0', 4);   // pos 127-130
        String campoFuturo = repeatChar('0', 40);        // pos 131-170

        // --- Construir la nueva primera línea (respetando índices 1-based provistos) ---
        StringBuilder result = new StringBuilder();

        // 1-2: "RC"
        result.append("RC");

        // 3-18: NIT (16)
        result.append(fitToLength(nit, 16));

        // 19-26: servicio + subservicio (8)
        result.append(fitToLength(servicioFull8, 8));

        // 27-42: numeroProductoOrigen (16)
        result.append(fitToLength(numeroProducto, 16));

        // 43-44: Tipo de cuenta (2)
        result.append(fitToLength(tipoCuenta, 2));

        // 45-50: Código banco: lo dejamos igual que el original (6)
        result.append(fitToLength(codigoBancoOriginal, 6));

        // 51-68: Valor total de los traslados (16) -> conservar original
        result.append(fitToLength(valorTotalOriginal, 18 - 2)); // ya que indices en substring usé 50..67

        // 69-74: Número total de los traslados (6) -> conservar original
        result.append(fitToLength(numeroTotalOriginal, 6));

        // 75-82: Fecha del proceso (8) -> conservar original
        result.append(fitToLength(fechaProcesoOriginal, 8));

        // 83-88: Hora del proceso (6) -> conservar original
        result.append(fitToLength(horaProcesoOriginal, 6));

        // 89-92: Código del operador (4) -> ceros
        result.append(fitToLength(codigoOperador, 4));

        // 93-96: Código no procesado (4) -> 9999
        result.append(fitToLength(codigoNoProcesado, 4));

        // 97-104: Fecha de generación (8) -> ceros
        result.append(fitToLength(fechaGeneracion, 8));

        // 105-110: Hora de generación (6) -> ceros
        result.append(fitToLength(horaGeneracion, 6));

        // 111-112: Indicador de inscripción (2) -> ceros
        result.append(fitToLength(indicadorInscripcion, 2));

        // 113-114: Tipo de identificación (2) -> "03"
        result.append(fitToLength(tipoIdentificacion, 2));

        // 115-126: Número de cliente asignado por Davivienda (12) -> ceros
        result.append(fitToLength(numClienteDav, 12));

        // 127-130: Código de oficina de recaudo (4) -> ceros
        result.append(fitToLength(codOficinaRecaudo, 4));

        // 131-170: Campo futuro (40) -> ceros
        result.append(fitToLength(campoFuturo, 40));

        // Si el original tenía más contenido después de la posición 170, lo preservamos (pos 171 en adelante)
        String tail = "";
        if (original.length() > 170) {
            tail = original.substring(170);
        }
        result.append(tail);

        // Reemplazar la primera línea por la nueva
        lines.set(0, result.toString());

        // Escribir todas las líneas en la ruta quemada
        Path outPath = Paths.get(OUTPUT_PATH);
        // Asegurar directorio
        if (outPath.getParent() != null) {
            Files.createDirectories(outPath.getParent());
        }

        Files.write(outPath, lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);

        // Retornar la ruta absoluta para que el llamador la use/modifique después
        return outPath.toAbsolutePath().toString();
    }

    // ---------------- Helper methods ----------------

    private static String safeSubstring(String s, int startInclusiveZeroBased, int endExclusiveZeroBased) {
        // start and end are zero-based indexes for Java substring
        int len = s.length();
        if (startInclusiveZeroBased >= len) return repeatChar(' ', Math.max(0, endExclusiveZeroBased - startInclusiveZeroBased));
        int end = Math.min(len, endExclusiveZeroBased);
        String sub = s.substring(startInclusiveZeroBased, end);
        // si quedó corto, rellenar a la derecha con espacios
        if (sub.length() < (endExclusiveZeroBased - startInclusiveZeroBased)) {
            StringBuilder sb = new StringBuilder(sub);
            while (sb.length() < (endExclusiveZeroBased - startInclusiveZeroBased)) sb.append(' ');
            sub = sb.toString();
        }
        return sub;
    }

    private static String repeatChar(char c, int count) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++) sb.append(c);
        return sb.toString();
    }

    private static String cleanAndPadLeft(String value, int totalLen) {
        if (value == null) value = "";
        // eliminar espacios y guiones comunes en NIT
        value = value.replaceAll("[\\s\\-]", "");
        if (value.length() > totalLen) {
            // si viene más larga, tomamos la derecha (últimos dígitos) OR podrías preferir cortar la izquierda
            value = value.substring(value.length() - totalLen);
        }
        return padLeft(value, totalLen, '0');
    }

    private static String padLeft(String s, int length, char pad) {
        if (s == null) s = "";
        if (s.length() >= length) return s;
        StringBuilder sb = new StringBuilder();
        for (int i = s.length(); i < length; i++) sb.append(pad);
        sb.append(s);
        return sb.toString();
    }

    private static String fitToLength(String s, int length) {
        if (s == null) s = "";
        if (s.length() == length) return s;
        if (s.length() > length) return s.substring(0, length);
        // si es más corto: por defecto relleno a la derecha con espacios
        StringBuilder sb = new StringBuilder(s);
        while (sb.length() < length) sb.append(' ');
        return sb.toString();
    }
}
