protected Object[] getDatosYMovimientos(String tipoProducto,
                                        String numProducto,
                                        String[] arrayVents,
                                        Date fechaConsulta,
                                        String[] arrFechaHora,
                                        boolean excluirCancelados,
                                        boolean incluirSaldos,
                                        String[] datosCta,
                                        String[] datosTitular) throws Exception {

    try {
        // 0 -> String[] datosCuenta (saldos/datos)
        // 1 -> List<MovimientoStratus> movimientos
        Object[] arrayReturn = new Object[2];

        boolean selectProdConsMov = false; // Selecciona el producto en "CONSULTA MOVIMIENTO"
        boolean esCuentaCorrOAh = tipoProducto.equals(CTA_CORRIENTE) || tipoProducto.equals(CTA_AHORROS);

        // Abre/activa Stratus si es necesario
        this.openStratus();

        // =====================================================================
        // 1. CONSULTA DE DATOS / SALDOS SEGÚN TIPO DE PRODUCTO Y TITULAR
        // =====================================================================
        boolean titularNoDefinido = (datosTitular == null
                || datosTitular.length == 0
                || datosTitular[0] == null);

        if (esCuentaCorrOAh && titularNoDefinido) {
            // Cuenta de ahorros/corriente SIN datos de titular: va a PT_CONSULTA_MAESTRAS
            this.irConsultaMaestra();
            arrayReturn[0] = this.getSaldosDatosCta(tipoProducto, numProducto, incluirSaldos, null, datosCta);

            if (this.errorConsultaSaldos) {
                this.returnInicio();
                return arrayReturn; // Error: no continúa a consulta de movimientos
            }

        } else {
            // Hay datos de titular o no es cuenta de ahorros/corriente
            if (titularNoDefinido) {
                // Sin datos de titular: va a consulta maestra y luego a consulta de movimientos
                this.irConsultaMaestra();
                selectProdConsMov = true;

            } else {
                // Con datos de titular -> consulta en PT_CONSULTA_PORTAF_NIT
                String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(datosTitular[0]);
                String numDoc = datosTitular[1];

                this.irConsultaPortafolio();

                // 0: mensajeError, 1: pantalla
                String[] arrCursorEnProd = this.ubicarCursorEnProducto(
                        tipoDoc,
                        numDoc,
                        tipoProducto,
                        numProducto,
                        true
                );

                if (!arrCursorEnProd[0].isEmpty()) {
                    this.returnInicio();
                    arrayReturn[0] = new String[]{arrCursorEnProd[0]};
                    return arrayReturn; // No se lanza excepción: se devuelve el error en el array
                }

                // -----------------------------------------------------------------
                // Productos que NO son ahorros/corriente
                // -----------------------------------------------------------------
                if (!esCuentaCorrOAh) {
                    int totalDatos = 0;
                    if (datosCta != null && datosCta[0] != null) {
                        totalDatos = datosCta.length;
                    }

                    int numDatosSaldos = incluirSaldos ? 4 : 0;
                    String[] arrDatosEmpty = new String[numDatosSaldos + totalDatos];

                    int posInic = 0;

                    if (incluirSaldos) {
                        posInic = 3;

                        // F1: consulta de saldos
                        this.ctrlX(1);
                        String pantallaSaldos = this.read();
                        this.saveEvidence("SaldoProducto-" + numProducto);

                        // 0-Saldo Disp, 1-Valor Mora, 2-Valor Cuota, 3-Pago por aplicar
                        String[] arrSaldos = this.getDatosPantallaSaldos(pantallaSaldos, tipoProducto);

                        // Limpieza inicial
                        arrDatosEmpty[2] = "";
                        arrDatosEmpty[3] = "";

                        if (tipoProducto.equals(CREDITO)) {
                            arrDatosEmpty[0] = arrSaldos[2];
                            arrDatosEmpty[1] = arrSaldos[4];
                            arrDatosEmpty[2] = arrSaldos[6];
                            arrDatosEmpty[3] = arrSaldos[8];
                        } else if (tipoProducto.equals(TARJETA_CREDITO)) {
                            arrDatosEmpty[0] = arrSaldos[0];
                            arrDatosEmpty[1] = arrSaldos[1];
                            arrDatosEmpty[2] = arrSaldos[2];
                            arrDatosEmpty[3] = arrSaldos[3];
                        } else if (tipoProducto.equals(FONDO_INVERSION)) {
                            arrDatosEmpty[0] = arrSaldos[3];
                            arrDatosEmpty[1] = arrSaldos[1];
                        }

                        // Regresa a Consulta por NIT dejando el cursor en el producto
                        this.escapeQ(1);
                        this.down(1);
                        this.tab(2);
                        this.up(1);

                        // Reubica cursor en producto (sin evidencia, no es primera consulta)
                        this.ubicarCursorEnProducto(
                                tipoDoc,
                                numDoc,
                                tipoProducto,
                                numProducto,
                                false,
                                false
                        );
                    }

                    // Llena el resto de datos con vacío (no hay forma de consultarlos)
                    for (int posArr = posInic; posArr < totalDatos; posArr++) {
                        arrDatosEmpty[posArr] = "";
                    }

                    arrayReturn[0] = arrDatosEmpty;

                } else if (datosCta != null && datosCta[0] != null) {
                    // Ahorros/corriente con datosCta -> consulta de datos
                    this.ctrlX(2); // F2: DATOS CTA
                    this.saveEvidence("DatosCta-" + tipoProducto + this.numProdCompleto);

                    String pantallaDatosCta = this.read();
                    arrayReturn[0] = this.getSaldosDatosCta(
                            tipoProducto,
                            numProducto,
                            incluirSaldos,
                            pantallaDatosCta,
                            datosCta
                    );

                    // Hubo ingreso adicional (Datos) antes de ir a Movimientos
                    this.numEscapeQInicio++;

                    // Si es cuenta migrada, almacena en diccionario de cuentas asociadas
                    boolean esMigrada = esCuentaMigrada(this.numProdCompleto);
                    if (esMigrada) {
                        String keyDic = tipoProducto + "-" + this.numProdCompleto;
                        if (!dicCtasAsoc_Migradas.containsKey(keyDic)) {
                            String valorAsoc = Util.getTextoEntre(
                                    pantallaDatosCta,
                                    "DATOS PERSONALES DEL PRODUCTO :",
                                    "NIT"
                            );
                            dicCtasAsoc_Migradas.put(keyDic, valorAsoc);
                        }
                    }
                }
            }
        }

        // =====================================================================
        // 2. CONSULTA DE MOVIMIENTOS
        // =====================================================================

        // F4: MOVIMIENTOS
        this.ctrlX(4);

        // Espera a PT_CONSULTA_MOVIMIENTO
        String textoEnPantalla = this.read(PT_CONSULTA_MOVIMIENTO);

        // ---------------------------------------------------------------------
        // Dejar cursor en el campo FECHA
        // ---------------------------------------------------------------------
        if (selectProdConsMov) {
            // Selecciona el PROD y ubica cursor en número de cuenta
            textoEnPantalla = this.seleccionarDato(
                    tipoProducto,
                    "PROD",
                    "CUENTA   NRO",
                    StratusBase.MODE_LETTER
            );

            this.tab(1);
            this.borrarValCampo();

            if (numProducto.length() > TAM_NUM_CTA) {
                numProducto = Util.right(numProducto, TAM_NUM_CTA);
            }

            this.paste(numProducto);

            // Si no se movió al campo FECHA, hace TAB manual
            if (numProducto.length() < TAM_NUM_CTA) {
                this.tab(1);
            }

        } else {
            // Ya está en la pantalla de movimiento; dos TABs dejan el cursor en FECHA
            this.tab(2);
        }

        // ---------------------------------------------------------------------
        // Ajuste de fecha / VENT
        // ---------------------------------------------------------------------
        boolean evalSoloFecha = (arrFechaHora[0].length() == 4); // solo "MMDD"

        String fechaHoy = Util.dateToString("yyyymmdd");
        String fechaIngresar = Util.dateToString(fechaConsulta, "yyyymmdd");

        if (fechaIngresar.equals(fechaHoy)) {
            // Fecha actual -> pasa a siguiente campo
            this.tab(1);
        } else {
            // Ingresa fecha exacta
            this.paste(fechaIngresar); // deja el cursor en campo VENT
        }

        // =====================================================================
        // 3. RECORRIDO DE VENTANAS Y PANTALLAS DE MOVIMIENTOS
        // =====================================================================

        List<MovimientoStratus> listaMovs = new ArrayList<>();

        // F1: por defecto primer VENT = MovimientoStratus.VENT_INDIC
        this.ctrlX(1);

        textoEnPantalla = this.ubicarPantallaCon1erMovimientoBuscado(arrFechaHora, evalSoloFecha);

        if (textoEnPantalla == null) {
            // No hay movimientos
            this.escapeQ(1);
            this.returnInicio();
            arrayReturn[1] = listaMovs;
            return arrayReturn;
        }

        int ultPos = arrFechaHora.length - 1;
        String horasEvi = Util.right(arrFechaHora[0].trim(), 4)
                + "a"
                + Util.right(arrFechaHora[ultPos].trim(), 4)
                + "_"; // HHMMaHHMM_

        String[] arrVents = Util.removeDuplicates(arrayVents); // Garantiza que cada VENT esté una sola vez
        int totalVents = arrVents.length;

        int numPantalla = 1;
        int numMovTotal = 0;

        boolean terminarBusqueda = false;
        boolean yaTomoMovs = false;

        do {
            String ventActual = MovimientoStratus.VENT_INDIC;
            boolean enPantallaVent = true;

            // A partir de la 2da pantalla, hay que volver a consultar el VENT INDIC
            if (numPantalla > 1 && totalVents != 0) {
                String lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
                this.ctrlX(1); // ALT-F1 : CONSULTAR
                textoEnPantalla = this.readAlCambio(lastPantalla);
            }

            int firstReng = 0;
            int lastReng = 0;
            int posVent = -1; // -1 corresponde a la ventana INDIC

            List<Integer> listaRenglonMovCancelado = new ArrayList<>();

            do {
                int numMov = numMovTotal;

                if (!enPantallaVent) {
                    String lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
                    this.ctrlX(1); // muestra datos

                    if (ventActual.equals(MovimientoStratus.VENT_TAUTO)) {
                        this.ctrlX(1); // para TAUTO es doble
                    }

                    textoEnPantalla = this.readAlCambio(lastPantalla);
                }

                String[] arrayLineas = textoEnPantalla.split("\n");

                // Rango de renglones con movimientos en esta pantalla
                if (firstReng == 0) {
                    firstReng = RENG_INICIO_MOVS + 1;
                    if (numPantalla == 1) {
                        firstReng = this.RENG_PRIMER_MOV;
                    }
                    lastReng = RENG_FIN_MOVS;
                }

                boolean tomoEvidencia = false;
                String nbEvidence = "";

                for (int renglon = firstReng; renglon <= lastReng; renglon++) {
                    String linea = arrayLineas[renglon];

                    if (linea.trim().isEmpty()) {
                        // No hay más movimientos visibles en esta pantalla
                        if (posVent == totalVents - 1 || renglon == firstReng) {
                            terminarBusqueda = true;
                        }
                        break;
                    }

                    // -------------------------------------------------------------
                    // EXCLUSIÓN DE MOVIMIENTOS CANCELADOS
                    // -------------------------------------------------------------
                    boolean esMovCancelado = false;

                    if (excluirCancelados) {
                        if (posVent == -1) {
                            // En VENT INDIC: columna "IND" (posición 74, largo 3)
                            esMovCancelado = Util.mid(linea, 74, 3).trim().equalsIgnoreCase("C");
                            if (esMovCancelado) {
                                listaRenglonMovCancelado.add(renglon);
                            }
                        } else {
                            // En otras VENT: se cruza con la lista de renglones cancelados
                            esMovCancelado = listaRenglonMovCancelado.contains(renglon);
                        }

                        if (esMovCancelado) {
                            continue; // no procesa este movimiento
                        }
                    }

                    // -------------------------------------------------------------
                    // EVALUACIÓN DE RANGO FECHA / HORA
                    // -------------------------------------------------------------
                    String fechaHoraMov;

                    if (evalSoloFecha) {
                        fechaHoraMov = Util.mid(linea, 2, 4); // MMDD
                    } else {
                        fechaHoraMov = Util.mid(linea, 2, 10); // "MMDD HHMM "
                    }

                    boolean dentroDeRango = arrFechaHora[0].compareTo(fechaHoraMov) <= 0
                            && fechaHoraMov.compareTo(arrFechaHora[ultPos]) <= 0;

                    if (dentroDeRango) {
                        // Toma evidencia una sola vez por pantalla/VENT cuando encuentra el primer movimiento válido
                        if (!tomoEvidencia) {
                            nbEvidence = this.saveEvidence(
                                    "ConsultaMovs_" + horasEvi + numPantalla + "_" + ventActual
                            );
                            tomoEvidencia = true;
                        }

                        if (!yaTomoMovs) {
                            firstReng = renglon;
                        }

                        yaTomoMovs = true;

                        if (posVent == -1) {
                            // En la ventana INDIC se crea la instancia del movimiento
                            listaMovs.add(new MovimientoStratus());
                        }

                        MovimientoStratus mov = listaMovs.get(numMov);
                        mov.setearDatosXVent(ventActual, linea);
                        mov.setProducto(this.tipoCtaReal, this.numProdCompleto);
                        mov.setNumRenglon(renglon);
                        mov.addEvidence(nbEvidence);

                        numMov++;

                        // Si es el último VENT y último renglón (no estándar) -> termina búsqueda
                        if (posVent == totalVents - 1 && renglon == lastReng && lastReng != RENG_FIN_MOVS) {
                            terminarBusqueda = true;
                        }

                    } else if (yaTomoMovs) {
                        // Ya no está en rango y ya tomó movimientos: no hay más para este VENT
                        lastReng = renglon - 1;
                        if (posVent == totalVents - 1 || lastReng < firstReng) {
                            terminarBusqueda = true;
                        }
                        break;
                    }
                }

                // Siguiente VENT
                posVent++;
                if (posVent < totalVents) {
                    ventActual = arrVents[posVent];
                }
                enPantallaVent = false;

                numMovTotal = numMovTotal + 0; // mantiene coherencia visual, aunque no cambia valor aquí

            } while (posVent < totalVents && !terminarBusqueda);

            // Si aún hay más pantallas, pasa a la siguiente
            if (!terminarBusqueda) {
                this.ctrlX(2); // ALT-F2 : PÁG SIG
                numPantalla++;

                if (totalVents == 0) {
                    // Solo se requiere la info de la ventana INDIC
                    textoEnPantalla = this.readAlCambio(textoEnPantalla);
                }

                // numMovTotal debe ir acumulando los movimientos creados
                numMovTotal = listaMovs.size();
            }

        } while (!terminarBusqueda);

        // =====================================================================
        // 4. SALIDA LIMPIA
        // =====================================================================
        this.escapeQ(1);   // Deja Stratus en la pantalla donde se hizo la consulta de movimientos
        this.returnInicio();

        arrayReturn[1] = listaMovs;
        return arrayReturn;

    } catch (Exception e) {
        // Mantengo exactamente el comportamiento original: atrapa la excepción,
        // espera y devuelve null.
        Util.wait(1);
    }

    return null;
}
