package launchTest;

import library.core.BaseTestNG;
import library.reporting.Reporter;

import java.io.File;
import java.io.PrintWriter;
import java.io.StringWriter;

import ControllerPyme.ControllerTestNomProve;
import dav.library.common.DatosEmpresarial;
import dav.library.reporting.EvidencePdfFile;
import library.settings.SettingsRun;

/**
 * Launcher ligero que orquesta y delega al PymeFlowController. Mantiene la API
 * pública original y delega la implementación concreta.
 */
public class LaunchTestNomProv extends BaseTestNG {

	private ControllerTestNomProve Controller;

	@Override
	public void launchData() {
		SettingsRun.ARRAY_DATA_PARAMS = new String[] { "Cliente Empresarial", "Tipo Identificación", "Id usuario",
				"Clave personal o CVE", "Tipo Token", "Semilla / Valor Estático / Celular", "Tipo ID Empresa",
				"Numero ID Empresa", "Nombre Empresa", "Servicio", "Tipo producto origen / Franquicia",
				"Número producto origen", "Archivo Destinos txt" };
		Reporter.initializeEvidenceType(new EvidencePdfFile());
		SettingsRun.DEFAULT_HEADER = 1;
	}

	@Override
	public void initializeControllerAndConfiguration() throws Exception {
		try {
			Controller = new ControllerTestNomProve();
			SettingsRun.getTestData().addParametersNotExist("Número Aprobación");
		} catch (Exception e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Error al inicializar controller: " + e.getMessage());
			logException(e);
			// NO llamar a exitTestIteration - permitir que continúe con la siguiente iteración
		}
	}

	@Override
	public void doingTest() throws Exception {
		int iteracionActual = SettingsRun.getTestData().getCurrentExec();
		Reporter.write("========== INICIANDO ITERACIÓN " + iteracionActual + " ==========");
		
		try {
			// Validar datos antes de ejecutar
			if (!validateDataSafe()) {
				Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Validación de datos fallida");
				Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
				// NO llamar a exitTestIteration - solo retornar para pasar a la siguiente
				return;
			}
			
			// Ejecutar el test con manejo de excepciones
			if (Controller != null) {
				Controller.doingTest();
			} else {
				Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Controller no inicializado");
				Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
				return;
			}
			
			Reporter.write("========== ITERACIÓN " + iteracionActual + " COMPLETADA ==========");
			
		} catch (org.openqa.selenium.NoSuchSessionException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Sesión de Selenium perdida");
			logException(e);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (org.openqa.selenium.NoSuchWindowException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Ventana del navegador cerrada");
			logException(e);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (org.openqa.selenium.WebDriverException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Error de WebDriver - " + e.getMessage());
			logException(e);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (java.lang.NullPointerException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": NullPointerException - " + e.getMessage());
			logException(e);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (java.io.IOException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Error de I/O - " + e.getMessage());
			logException(e);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (InterruptedException e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Hilo interrumpido");
			logException(e);
			Thread.currentThread().interrupt();
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} catch (Throwable t) {
			// Captura CUALQUIER excepción o error no manejado
			Reporter.reportEvent(Reporter.MIC_FAIL, "Iteración " + iteracionActual + ": Error inesperado - " + t.getClass().getName() + " - " + t.getMessage());
			logException(t);
			Reporter.write("========== ITERACIÓN " + iteracionActual + " TERMINADA CON ERRORES ==========");
			// NO llamar a exitTestIteration
		} finally {
			// Asegurar limpieza de recursos SOLO de esta iteración
			cleanupResources();
		}
	}

	/**
	 * Validación de datos con manejo de excepciones
	 * IMPORTANTE: NO usa exitTestIteration, solo retorna false
	 */
	private boolean validateDataSafe() {
		try {
			String clienteEmpresarial = SettingsRun.getTestData().getParameter("Cliente Empresarial");
			String tipoIdentificacion = SettingsRun.getTestData().getParameter("Tipo Identificación");
			String idUsuario = SettingsRun.getTestData().getParameter("Id usuario");
			String clavePersonaloCVE = SettingsRun.getTestData().getParameter("Clave personal o CVE");
			String tipoToken = SettingsRun.getTestData().getParameter("Tipo Token");
			String semilla = SettingsRun.getTestData().getParameter("Semilla / Valor Estático / Celular");

			String tipoIDEmpresa = SettingsRun.getTestData().getParameter("Tipo ID Empresa");
			String numeroIDEmpresa = SettingsRun.getTestData().getParameter("Numero ID Empresa");
			String nombreEmpresa = SettingsRun.getTestData().getParameter("Nombre Empresa");
			String servicio = SettingsRun.getTestData().getParameter("Servicio");
			String tipoProductoOrigen = SettingsRun.getTestData().getParameter("Tipo producto origen / Franquicia");
			String numeroProductoOrigen = SettingsRun.getTestData().getParameter("Número producto origen");
			String archivoDestinosTxt = SettingsRun.getTestData().getParameter("Archivo Destinos txt");

			String[] valores = { clienteEmpresarial, tipoIdentificacion, idUsuario, clavePersonaloCVE, tipoToken, semilla,
					tipoIDEmpresa, numeroIDEmpresa, nombreEmpresa, servicio, tipoProductoOrigen, numeroProductoOrigen,
					archivoDestinosTxt };

			String[] titulos = { "Cliente Empresarial", "Tipo Identificación", "Id usuario", "Clave personal o CVE",
					"Tipo Token", "Semilla / Valor Estático / Celular", "Tipo ID Empresa", "Numero ID Empresa",
					"Nombre Empresa", "Servicio", "Tipo producto origen / Franquicia", "Número producto origen",
					"Archivo Destinos txt" };

			// Validar que no haya campos vacíos
			for (int i = 0; i < valores.length; i++) {
				if (valores[i] == null || valores[i].trim().isEmpty()) {
					Reporter.reportEvent(Reporter.MIC_FAIL, "Falta diligenciar el dato: " + titulos[i]);
					return false; // NO llamar exitTestIteration - solo retornar false
				}
			}

			// Validar que el archivo exista
			File archivo = new File(archivoDestinosTxt);
			if (!archivo.exists() || archivo.isDirectory()) {
				Reporter.reportEvent(Reporter.MIC_FAIL,
						"El archivo de destinos no existe o es un directorio: " + archivoDestinosTxt);
				return false; // NO llamar exitTestIteration - solo retornar false
			}
			
			return true;
			
		} catch (Exception e) {
			Reporter.reportEvent(Reporter.MIC_FAIL, "Error durante la validación: " + e.getMessage());
			logException(e);
			return false; // NO llamar exitTestIteration - solo retornar false
		}
	}

	/**
	 * Limpieza de recursos del controller
	 */
	private void cleanupResources() {
		try {
			if (Controller != null) {
				Controller.destroy();
			}
		} catch (Exception e) {
			Reporter.write("Error al limpiar recursos del controller: " + e.getMessage());
		}
	}

	/**
	 * Registra el stack trace completo de una excepción
	 */
	private void logException(Throwable t) {
		try {
			StringWriter sw = new StringWriter();
			PrintWriter pw = new PrintWriter(sw);
			t.printStackTrace(pw);
			String stackTrace = sw.toString();
			Reporter.write("Stack Trace completo:");
			Reporter.write(stackTrace);
		} catch (Exception e) {
			Reporter.write("No se pudo registrar el stack trace: " + e.getMessage());
		}
	}
}
