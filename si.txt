package launchTest;

import library.core.BaseTestNG;
import library.reporting.Reporter;

import java.io.File;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import ControllerPyme.ControllerTestNomProve;
import dav.library.common.DatosEmpresarial;
import dav.library.reporting.EvidencePdfFile;
import library.settings.SettingsRun;

/**
 * Launcher ligero que orquesta y delega al PymeFlowController. Mantiene la API
 * pública original y delega la implementación concreta.
 */
public class LaunchTestNomProv extends BaseTestNG {

    private ControllerTestNomProve Controller;

    @Override
    public void launchData() {
        SettingsRun.ARRAY_DATA_PARAMS = new String[] { "Cliente Empresarial", "Tipo Identificación", "Id usuario",
                "Clave personal o CVE", "Tipo Token", "Semilla / Valor Estático / Celular", "Tipo ID Empresa",
                "Numero ID Empresa", "Nombre Empresa", "Servicio", "Tipo producto origen / Franquicia",
                "Número producto origen", "Archivo Destinos txt" };
        Reporter.initializeEvidenceType(new EvidencePdfFile());
        SettingsRun.DEFAULT_HEADER = 1;
    }

    @Override
    public void initializeControllerAndConfiguration() throws Exception {
        Controller = new ControllerTestNomProve();
        SettingsRun.getTestData().addParametersNotExist("Número Aprobación");
    }

    /**
     * Cambiado para ejecutar el controller en un hilo separado pero esperar su
     * terminación. Se crea una instancia nueva del controller dentro del task
     * para evitar compartir estado mutable.
     */
    @Override
    public void doingTest() throws Exception {
        validateData();

        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future<?> future = executor.submit(() -> {
            try {
                // Instancia nueva por ejecución (no compartir estado)
                ControllerTestNomProve controllerInstance = new ControllerTestNomProve();
                controllerInstance.doingTest();
            } catch (Exception e) {
                // transformar excepciones checked para que se empaqueten en ExecutionException
                throw new RuntimeException(e);
            }
        });

        try {
            // Espera y propaga excepción original si la hubo
            future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof Exception) {
                throw (Exception) cause;
            } else {
                throw new Exception(cause);
            }
        } finally {
            // intentamos detener el executor (no deberías quedarte con hilos huérfanos)
            executor.shutdownNow();
        }
    }

    public void validateData() throws Exception {

        String clienteEmpresarial = SettingsRun.getTestData().getParameter("Cliente Empresarial");
        String tipoIdentificacion = SettingsRun.getTestData().getParameter("Tipo Identificación");
        String idUsuario = SettingsRun.getTestData().getParameter("Id usuario");
        String clavePersonaloCVE = SettingsRun.getTestData().getParameter("Clave personal o CVE");
        String tipoToken = SettingsRun.getTestData().getParameter("Tipo Token");
        String semilla = SettingsRun.getTestData().getParameter("Semilla / Valor Estático / Celular");

        String tipoIDEmpresa = SettingsRun.getTestData().getParameter("Tipo ID Empresa");
        String numeroIDEmpresa = SettingsRun.getTestData().getParameter("Numero ID Empresa");
        String nombreEmpresa = SettingsRun.getTestData().getParameter("Nombre Empresa");
        String servicio = SettingsRun.getTestData().getParameter("Servicio");
        String tipoProductoOrigen = SettingsRun.getTestData().getParameter("Tipo producto origen / Franquicia");
        String numeroProductoOrigen = SettingsRun.getTestData().getParameter("Número producto origen");
        String archivoDestinosTxt = SettingsRun.getTestData().getParameter("Archivo Destinos txt");

        String[] valores = { clienteEmpresarial, tipoIdentificacion, idUsuario, clavePersonaloCVE, tipoToken, semilla,
                tipoIDEmpresa, numeroIDEmpresa, nombreEmpresa, servicio, tipoProductoOrigen, numeroProductoOrigen,
                archivoDestinosTxt };

        String[] titulos = { "Cliente Empresarial", "Tipo Identificación", "Id usuario", "Clave personal o CVE",
                "Tipo Token", "Semilla / Valor Estático / Celular", "Tipo ID Empresa", "Numero ID Empresa",
                "Nombre Empresa", "Servicio", "Tipo producto origen / Franquicia", "Número producto origen",
                "Archivo Destinos txt" };

        for (int i = 0; i < valores.length; i++) {
            if (valores[i] == null || valores[i].trim().isEmpty()) {
                Reporter.reportEvent(Reporter.MIC_FAIL, "Falta diligenciar el dato: " + titulos[i]);
                SettingsRun.exitTestIteration();
            }
        }

        File archivo = new File(archivoDestinosTxt);
        if (!archivo.exists() || archivo.isDirectory()) {
            Reporter.reportEvent(Reporter.MIC_FAIL,
                    "El archivo de destinos no existe o es un directorio: " + archivoDestinosTxt);
            SettingsRun.exitTestIteration();
        }
    }

}
