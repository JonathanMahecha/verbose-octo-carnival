// Imports necesarios (añádelos a la cabecera de la clase si no están)
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.function.BiFunction;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// Método público (firma original intacta)
public void ValidacionMovimientoStratus(String servicio, String tipoIDEmpresa, String numIdEmpresa,
        String tipoDocumento, String numeroDoc, String tipoProduct, String numeroProducto,
        StratusProductos instanciaStratus) throws Exception {

    // --- Preparación fecha/hora ---
    WebElement elFecha = this.element(fechaTx);
    String fechaTxStr = this.getText(elFecha);
    Date fechaConsulta = DXCUtil.stringToDate(fechaTxStr, "dd/MM/yyyy");
    Date fechaConsultaStratus = DXCUtil.dateAdd(fechaConsulta, Calendar.MINUTE, -2);
    Reporter.reportEvent(Reporter.MIC_INFO, "Fecha y hora de la tx: " + fechaConsultaStratus);

    WebElement elHora = this.element(horaTx);
    String horaTxRaw = this.getText(elHora);
    String horaTxMov = DXCUtil.hourToStringFormat(horaTxRaw, "HHmm");

    // --- Titular según reglas originales ---
    if (instanciaStratus == null) {
        instanciaStratus = new StratusProductos(SettingsRun.getGlobalData("STRATUS.usuario"),
                SettingsRun.getGlobalData("STRATUS.password"));
    }

    String tipoProd = (instanciaStratus != null) ? instanciaStratus.getTipoCuenta(tipoProduct) : tipoProduct;
    String[] datosTitular = decidirTitular(tipoProd, tipoProduct, tipoIDEmpresa, numIdEmpresa, tipoDocumento,
            numeroDoc);

    String[] arrayVents = { MovimientoStratus.VENT_UNID, MovimientoStratus.VENT_IVA,
            MovimientoStratus.VENT_SALDO, MovimientoStratus.VENT_EMERG };

    if (instanciaStratus == null) {
        Reporter.reportEvent(Reporter.MIC_FAIL, "Instancia Stratus no inicializada.");
        return;
    }

    List<MovimientoStratus> movimientosRaw = instanciaStratus.getMovimientosEnRango(tipoProd, numeroProducto,
            arrayVents, fechaConsultaStratus, 1, datosTitular);

    if (SettingsRun.esIteracionFinal()) {
        instanciaStratus.closeStratus();
    }

    if (movimientosRaw == null) {
        Reporter.reportEvent(Reporter.MIC_FAIL, "POR FAVOR VERIFICAR DATOS DE CONSULTA");
        return;
    }

    Reporter.write(" ");
    Reporter.write("*** CONSULTA DE MOVIMIENTOS EN STRATUS");
    Reporter.write(" ");
    Reporter.write("           FECHA | HORA |   TALON  | TIPO  |  OFRE | VALOR TOTAL | MTVO  |  UNIDAD  |  VALOR CHEQUE  |  VALOR IVA  |  SALDO ANTERIOR  |  GMF | IND");
    Reporter.write(" ");

    // Lista que mantiene la compatibilidad con el resto del código
    List<String[]> movimientosStratus = new ArrayList<>();

    // Helper 'safe' para evitar OOB cuando se accede datos[] más adelante
    BiFunction<String[], Integer, String> safe = (arr, idx) -> {
        if (arr == null || idx < 0 || idx >= arr.length) return "";
        return arr[idx] == null ? "" : arr[idx].trim();
    };

    // Parseo y filtrado inicial de movimientos (conserva la normalización original)
    for (MovimientoStratus mov : movimientosRaw) {
        Util.wait(2); // como en el código original

        String raw = mov.toString();
        String normalized = normalizeRawMovimiento(raw);
        if (normalized.isEmpty()) continue;

        String[] datos = normalized.split("\\|");

        String fecha = safe.apply(datos, 0);
        String hora = safe.apply(datos, 1);
        String talon = safe.apply(datos, 3);
        String tipoStratus = safe.apply(datos, 4);
        String oficinaStratus = safe.apply(datos, 5);

        double valorTotal = safeParseDouble(safe.apply(datos, 6));
        double unidad = safeParseDouble(safe.apply(datos, 10));
        double valorCheque = safeParseDouble(safe.apply(datos, 11));
        String ivam = safe.apply(datos, 15);
        String valorEmerg = safe.apply(datos, 14);
        String indCancelado = safe.apply(datos, 16);

        // Excluir oficinas específicas (comportamiento original)
        if (isExcludedOffice(oficinaStratus)) continue;

        String msgCancelado = ("true".equalsIgnoreCase(indCancelado)) ? "Cancelado" : " ";
        Reporter.write(String.format("Movimiento: %s | %s | %s | %s  |  %s | %s | %s  |  %s  |  %s  |  %s  |  %s  |  %s | %s",
                fecha, hora, talon, tipoStratus, oficinaStratus, BigDecimal.valueOf(valorTotal), safe.apply(datos, 7),
                BigDecimal.valueOf(unidad), BigDecimal.valueOf(valorCheque), ivam, safe.apply(datos, 9), valorEmerg,
                msgCancelado));

        // Construcción compatibilidad: el código original comprobaba contains("0034"/"0055"/"0041")
        String movr = String.join(" ", fecha, hora, talon, tipoStratus, oficinaStratus,
                BigDecimal.valueOf(valorTotal).toString(), safe.apply(datos, 7),
                BigDecimal.valueOf(unidad).toString(), BigDecimal.valueOf(valorCheque).toString(),
                ivam, safe.apply(datos, 9), valorEmerg, indCancelado);

        if (movr.contains("0034") || movr.contains("0055") || movr.contains("0041")) {
            // Nota: el original hacía split(",") -> mantengo por compatibilidad (aunque movr no tendrá comas)
            movimientosStratus.add(movr.split(","));
        }
    }

    // --- Preparar variables acumuladas ---
    double sumaMovimientos = 0.0, sumaUnidad = 0.0, sumaCheque = 0.0, sumaIva = 0.0, sumaGmf = 0.0;
    double saldoTotalFinalEsperado = 0.0;
    int posicionSaldoInicialpos = -1;
    int posicionSaldoInicialpos2 = -1;

    // --- Encontrar posición de saldo inicial según servicio (mantenido) ---
    switch (servicio) {
        case "Nómina": case "Pago de Nómina": case "Pago de Nóminas": case "Pago a Proveedores":
        case "Pagos a proveedores": case "Pagos proveedores": case "Proveedores": case "AFC":
        case "Pago a Créditos de Terceros": case "Pagos a créditos de terceros": case "Crédito.3ros":
        case "Pago de Servicios": case "Servicios": case "Transferencias Cuenta Inscrita":
        case "Cuenta Inscrita": case "Transferencias Cuenta No Inscrita":
        case "Transferencias Cuenta NO Inscrita": case "Cuenta No Inscrita": case "Transferencias Mismo NIT":
        case "Transferencia NIT Propio": case "Mismo NIT":
            double saldoInipo = 0.0;
            for (int i = 0; i < movimientosStratus.size(); i++) {
                String[] mv = movimientosStratus.get(i);
                if (mv.length == 0) continue;
                String[] datosMvIni = mv[0].split(" ");
                if (datosMvIni.length < 3) continue;
                try {
                    String numeroMovStr = datosMvIni[Math.max(0, datosMvIni.length - 3)];
                    BigDecimal movDecimal = new BigDecimal(numeroMovStr);
                    String movEntero = movDecimal.toBigInteger().toString();
                    BigDecimal saldoDecimal = new BigDecimal(this.saldoTotalInicial);
                    String saldoEntero = saldoDecimal.setScale(0, RoundingMode.DOWN).toPlainString();
                    if (movEntero.equals(saldoEntero)) {
                        posicionSaldoInicialpos = i;
                        if (datosMvIni.length > 10 && !datosMvIni[10].isEmpty()) {
                            saldoInipo = safeParseDouble(datosMvIni[10].trim().replace(",", ""));
                        } else {
                            saldoInipo = 0;
                        }
                        break;
                    }
                } catch (Exception ex) {
                    // seguir buscando si hay parse error
                }
            }

            // búsqueda por saldo disponible final (mantenida)
            for (int j = 0; j < movimientosStratus.size(); j++) {
                String[] mv = movimientosStratus.get(j);
                if (mv.length <= 1) continue;
                try {
                    if (mv[mv.length - 1]
                            .contains(this.saldoDisponibleFinal.substring(0, this.saldoDisponibleFinal.length() - 3))) {
                        posicionSaldoInicialpos2 = j;
                        break;
                    }
                } catch (Exception ignored) { }
            }

            if (posicionSaldoInicialpos2 != -1 && posicionSaldoInicialpos < posicionSaldoInicialpos2) {
                posicionSaldoInicialpos = posicionSaldoInicialpos2;
            }

            if (posicionSaldoInicialpos2 == -1 && !movimientosStratus.isEmpty()) {
                int cand = Math.max(0, movimientosStratus.size() - 2);
                String[] movimiento1 = movimientosStratus.get(cand);
                if (movimiento1.length > 0) {
                    String[] datosMov = movimiento1[0].split(" ");
                    if (datosMov.length > 10) {
                        try {
                            double saldoFinalPo = Double.parseDouble(datosMov[10].trim().replace(",", ""));
                            if (saldoFinalPo < safeParseDouble(this.saldoTotalInicial)) {
                                posicionSaldoInicialpos = cand;
                            }
                        } catch (Exception ignored) { }
                    }
                }
            }
            break;
        case "Pagos Propios":
            // comportamiento original: no acción
            break;
    }

    Reporter.write(" ");
    Reporter.write("*** Valores Cobros, IVA y GMF");
    Reporter.write(" ");

    String porGmf = "1.0040"; // fallback igual que original (si se recup. de datos, reemplazar)

    if (posicionSaldoInicialpos != -1) {

        // Acumular sumas desde posicionSaldoInicialpos
        for (int i = posicionSaldoInicialpos; i < movimientosStratus.size(); i++) {
            String[] mv = movimientosStratus.get(i);
            if (mv.length == 0) continue;
            String[] datosMv = mv[0].split(" ");
            if (datosMv.length < 12) continue;

            double valorMovimiento = safeParseDouble(datosMv[5].trim().replace(",", ""));
            String tipoMovimiento = datosMv[6].trim();
            double valorunida = safeParseDouble(datosMv[7].trim().replace(",", ""));
            double valorCheque = safeParseDouble(datosMv[8].trim().replace(",", ""));
            double valorIva = safeParseDouble(datosMv[9].trim().replace(",", ""));
            double emerg = safeParseDouble(datosMv[11].trim().replace(",", ""));
            String cancelados = (datosMv.length > 12) ? datosMv[12].trim() : "false";

            sumaMovimientos += valorMovimiento;
            sumaUnidad += valorunida;
            sumaCheque += valorCheque;
            sumaIva += Math.round(valorIva);
            sumaGmf += emerg;

            // Reportes y cálculo GMF/IVA (mismo comportamiento)
            double cobrovalorIva = 0.0;
            double cobrovalorGMF = 0.0;

            if (valorIva != 0) {
                Reporter.write("Valor Cobro Iva Movimiento: " + BigDecimal.valueOf(valorIva));
                cobrovalorIva = (valorMovimiento * 19 / 100);
                Reporter.write("Compara el Valor del Iva  : " + BigDecimal.valueOf(cobrovalorIva));
                cobrovalorIva = valorIva;
            } else if (valorIva == 0 && valorunida != 0) {
                Reporter.write("Para los movimientos cobros o 6 No se realiza la suma del Iva");
                Reporter.write("Posible Valor Cobro Iva que podria aparecer: " + BigDecimal.valueOf((valorunida * 19 / 100)));
            } else if (valorIva == 0 && valorunida == 0) {
                cobrovalorIva = (valorunida * 19 / 100);
                Reporter.write("Valor Cobro Iva: " + BigDecimal.valueOf(cobrovalorIva));
            }

            if (valorunida != 0) {
                if (valorIva == 0) {
                    cobrovalorGMF = calcularGmfSimple(valorMovimiento, porGmf);
                } else {
                    double cobrosuma = (valorMovimiento + cobrovalorIva);
                    cobrovalorGMF = calcularGmfSimple(cobrosuma, porGmf);
                }
            } else {
                double cobrosuma = (valorMovimiento + cobrovalorIva);
                cobrovalorGMF = calcularGmfSimple(cobrosuma, porGmf);
            }

            if (valorIva != 0) {
                double cobrosuma = (valorMovimiento + cobrovalorIva);
                Reporter.write("Valor de la Tx: " + BigDecimal.valueOf(valorMovimiento)
                        + " Mas el Valor IVA: " + BigDecimal.valueOf(cobrovalorIva) + " La Suma es de: "
                        + BigDecimal.valueOf(cobrosuma));
                Reporter.write(" ");
                Reporter.write("Valor Unidad: " + (cobrosuma + cobrovalorGMF));
            } else {
                double cobrosuma = (valorMovimiento + cobrovalorGMF);
                Reporter.write("Valor de la Tx: " + BigDecimal.valueOf(valorMovimiento)
                        + " Mas el Valor Gmf: " + BigDecimal.valueOf(cobrovalorGMF) + " La Suma es de: "
                        + BigDecimal.valueOf(cobrosuma));
                Reporter.write(" ");
                Reporter.write("Valor Unidad: " + cobrosuma);
            }

            Reporter.write(" ");
        }

        // --- Restas por cancelados (mismo comportamiento) ---
        double restaMovimientos = 0.0, restaUnidad = 0.0, restaCheque = 0.0, restaIva = 0.0, restaGmf = 0.0;
        String cancelados = "false";
        int canNumCancelados = 0;

        for (int i = posicionSaldoInicialpos; i < movimientosStratus.size(); i++) {
            String[] mv = movimientosStratus.get(i);
            if (mv.length == 0) continue;
            String[] datosMv = mv[0].split(" ");
            if (datosMv.length < 12) continue;

            double valorMovimiento = safeParseDouble(datosMv[5].trim().replace(",", ""));
            String tipoMovimiento = datosMv[6].trim();
            double valorunida = safeParseDouble(datosMv[7].trim().replace(",", ""));
            double valorCheque = safeParseDouble(datosMv[8].trim().replace(",", ""));
            double valorIva = safeParseDouble(datosMv[9].trim().replace(",", ""));
            double emerg = safeParseDouble(datosMv[11].trim().replace(",", ""));
            cancelados = datosMv[12].trim();

            if (tipoMovimiento.equals("307") || tipoMovimiento.equals("34") || tipoMovimiento.equals("741")) {
                restaMovimientos += valorMovimiento;
                restaUnidad += valorunida;
                restaCheque += valorCheque;
                restaIva += valorIva;
                restaGmf += emerg;
                canNumCancelados++;
            } else if (tipoMovimiento.equals("307") || tipoMovimiento.equals("34") || tipoMovimiento.equals("741")
                    || "true".equalsIgnoreCase(cancelados)) {
                restaMovimientos += valorMovimiento;
                restaUnidad += valorunida;
                restaCheque += valorCheque;
                restaIva += Math.round(valorIva);
                restaGmf += emerg;
                canNumCancelados++;
            }
        }

        double valorMov = (sumaMovimientos - restaMovimientos);
        double valorUnidad = (sumaUnidad - restaUnidad);
        double valorCheque = (sumaCheque - restaCheque);
        double valorIva = (sumaIva - restaIva);
        double valorGmf = (sumaGmf - restaGmf);

        Reporter.write(" ");
        Reporter.write("*** VALIDACIÓN DEL MOVIMIENTO");
        Reporter.write(" ");
        Reporter.write("SUMA de los Movimientos: " + BigDecimal.valueOf(sumaMovimientos));
        Reporter.write("SUMA de las Unidades: " + BigDecimal.valueOf(sumaUnidad));
        Reporter.write("SUMA de los Cheques: " + BigDecimal.valueOf(sumaCheque));
        Reporter.write("SUMA de los Iva: " + BigDecimal.valueOf(sumaIva));
        Reporter.write("SUMA de los GMF: " + BigDecimal.valueOf(sumaGmf));
        Reporter.write(" ");
        Reporter.write("Total de Movimientos Cancelados: " + canNumCancelados);

        if ("true".equalsIgnoreCase(cancelados)) {
            Reporter.write("SUMA de los Movimiento cancelado: " + BigDecimal.valueOf(restaMovimientos));
            Reporter.write("SUMA de los Unidad cancelado: " + BigDecimal.valueOf(restaUnidad));
            Reporter.write("SUMA de los Cheque cancelado: " + BigDecimal.valueOf(restaCheque));
            Reporter.write("SUMA de los Iva cancelado: " + BigDecimal.valueOf(restaIva));
            Reporter.write("SUMA de los GMF cancelado: " + BigDecimal.valueOf(restaGmf));
            Reporter.write(" ");
        }

        // --- Saldo esperado (misma fórmula) ---
        double saldoesperado;
        try {
            if (valorUnidad != 0) {
                saldoesperado = (Integer.parseInt(this.saldoTotalInicial) - valorUnidad - valorCheque);
            } else {
                saldoesperado = (Integer.parseInt(this.saldoTotalInicial) - valorMov - Math.round(valorIva) - valorGmf);
            }
        } catch (Exception ex) {
            saldoesperado = 0.0;
        }

        Reporter.write(" ");
        Reporter.write("*** HACIENDO LAS VALIDACIÓN DEL MOVIMIENTO");
        Reporter.write(" ");
        Reporter.write("Valor del Movimiento: " + BigDecimal.valueOf(valorMov));
        Reporter.write("Valor del Unidad: " + BigDecimal.valueOf(valorUnidad));
        Reporter.write("Valor del Cheque " + BigDecimal.valueOf(valorCheque));
        Reporter.write("Valor del Iva: " + BigDecimal.valueOf(valorIva));
        Reporter.write("Valor del GMF: " + BigDecimal.valueOf(valorGmf));

        saldoTotalFinalEsperado = saldoesperado;
        double diferencia;
        try {
            diferencia = (Integer.parseInt(this.saldoTotalFinal) - saldoTotalFinalEsperado);
        } catch (Exception ex) {
            diferencia = 0.0;
        }

        Reporter.write(" ");
        Reporter.reportEvent(Reporter.MIC_HEADER, "INFRORMACIÓN DE SALDO FINAL");
        Reporter.write(" ");
        Reporter.reportEvent(Reporter.MIC_INFO, "El Saldo Final Stratus : " + this.saldoTotalFinal);
        Reporter.reportEvent(Reporter.MIC_INFO, "El Saldo Final esperado: " + BigDecimal.valueOf(saldoTotalFinalEsperado));
        Reporter.write(" ");
        Reporter.reportEvent(Reporter.MIC_HEADER, "DIFERENCIAL ENTRE LOS SALDOS");
        Reporter.write(" ");
        Reporter.reportEvent(Reporter.MIC_INFO, "La diferencia entre los saldos final es: " + BigDecimal.valueOf(Math.round(diferencia)));

    } else {
        Reporter.reportEvent(Reporter.MIC_FAIL, "No se encontró el saldo inicial en los movimientos.");
    }
}

// -------------------- HELPERS PRIVADOS --------------------

// Patrones compilados una sola vez
private static final Pattern P_SALDO = Pattern.compile("SALDO\\s*:\\s*([0-9\\.,Ee\\-+]+)");
private static final Pattern P_UNID = Pattern.compile("UNID\\s*:\\s*([0-9\\.,Ee\\-+]+)(?:\\s*\\|\\s*([0-9\\.,Ee\\-+]+))?");
private static final Pattern P_EMERG = Pattern.compile("EMERG\\s*:\\s*([^|\\n]+?)\\s*(?:\\|\\s*([0-9+\\-Ee\\.,]+))?");
private static final Pattern P_IVA = Pattern.compile("IVA\\s*:?\\s*([0-9\\.,Ee\\-+]+)");

/** Normaliza el toString() del movimiento a una cadena delimitada por '|' */
private String normalizeRawMovimiento(String raw) {
    if (raw == null) return "";
    raw = raw.replaceAll("^\\[INDIC:\\s*", "").replaceAll("\\]\\s*$", "");

    Matcher mSaldo = P_SALDO.matcher(raw);
    if (mSaldo.find()) {
        raw = raw.substring(0, mSaldo.start()) + "|" + mSaldo.group(1) + "|" + raw.substring(mSaldo.end());
    }

    Matcher mUnid = P_UNID.matcher(raw);
    if (mUnid.find()) {
        String g1 = mUnid.group(1);
        String g2 = mUnid.group(2);
        if (g2 == null) g2 = "";
        raw = raw.substring(0, mUnid.start()) + "|" + g1 + (g2.isEmpty() ? "" : ("|" + g2)) + "|" + raw.substring(mUnid.end());
    }

    Matcher mEmerg = P_EMERG.matcher(raw);
    if (mEmerg.find()) {
        String g1 = (mEmerg.group(1) == null) ? "" : mEmerg.group(1).trim();
        g1 = g1.replace("|", "").replaceAll("\\s+", " ");
        String g2raw = (mEmerg.group(2) == null) ? "" : mEmerg.group(2).trim();
        String replacement;
        if (!g2raw.isEmpty()) {
            try {
                BigDecimal bd = new BigDecimal(g2raw.replace(",", "."));
                replacement = "|" + g1 + "|" + bd.toPlainString() + "|";
            } catch (Exception ex) {
                String fallback = g2raw.replaceAll("[^0-9\\.,\\-+EeLl]", "");
                replacement = "|" + g1 + (fallback.isEmpty() ? "|" : ("|" + fallback + "|"));
            }
        } else {
            replacement = "|" + g1 + "|";
        }
        raw = raw.substring(0, mEmerg.start()) + replacement + raw.substring(mEmerg.end());
    }

    Matcher mIva = P_IVA.matcher(raw);
    if (mIva.find()) {
        raw = raw.substring(0, mIva.start()) + "|" + mIva.group(1) + "|" + raw.substring(mIva.end());
    }

    raw = raw.replaceAll("\\s*\\|\\s*", "|").replaceAll("\\s+", " ").replaceAll("\\|{2,}", "|").trim();
    if (raw.startsWith("|")) raw = raw.substring(1);
    if (raw.endsWith("|")) raw = raw.substring(0, raw.length() - 1);

    return raw;
}

/** Conversión segura a double (0.0 si no es parseable) */
private double safeParseDouble(String s) {
    if (s == null) return 0.0;
    String tmp = s.trim().replaceAll(",", "");
    if (tmp.isEmpty()) return 0.0;
    try {
        return Double.parseDouble(tmp);
    } catch (NumberFormatException ex) {
        String cleaned = tmp.replaceAll("[^0-9\\-+Ee\\.]", "");
        try {
            return Double.parseDouble(cleaned);
        } catch (Exception ex2) {
            return 0.0;
        }
    }
}

/** Determina datos del titular segun reglas originales */
private String[] decidirTitular(String tipoProd, String tipoProduct, String tipoIDEmpresa, String numIdEmpresa,
        String tipoDocumento, String numeroDoc) {
    String[] datosTitular = new String[2];
    if ((tipoProd != null && tipoProd.contains("AH")) || (tipoProduct != null && tipoProduct.contains("CC"))) {
        datosTitular[0] = tipoIDEmpresa;
        datosTitular[1] = numIdEmpresa;
    } else if (tipoProduct != null && (tipoProduct.contains("CREDITO") || tipoProduct.contains("CRED")
            || tipoProduct.contains("ompanita"))) {
        datosTitular[0] = tipoIDEmpresa;
        datosTitular[1] = numIdEmpresa;
    } else {
        datosTitular[0] = tipoDocumento;
        datosTitular[1] = numeroDoc;
    }
    return datosTitular;
}

/** Comprueba si la oficina debe excluirse (lista original de códigos) */
private boolean isExcludedOffice(String oficina) {
    if (oficina == null) return true; // si no hay oficina mejor excluir para seguridad
    return oficina.contains("4636") || oficina.contains("4522") || oficina.contains("4863");
}

/** Calcula GMF según 'porGmf' (respeta la lógica original) */
private double calcularGmfSimple(double monto, String porGmf) {
    if (porGmf == null) porGmf = "1.0040";
    if (porGmf.contains("1.0040")) {
        Reporter.write("Valor Cobro  GMF: " + BigDecimal.valueOf((monto / 1000 * 4)));
        return (monto / 1000 * 4);
    } else if (porGmf.contains("1.0020")) {
        Reporter.write("Valor Cobro  GMF: " + BigDecimal.valueOf((monto / 1000 * 2)));
        return (monto / 1000 * 2);
    } else if (porGmf.contains("1.0030")) {
        Reporter.write("Valor Cobro  GMF: " + BigDecimal.valueOf((monto / 1000 * 3)));
        return (monto / 1000 * 3);
    } else if (porGmf.contains("1.0035")) {
        Reporter.write("Valor Cobro  GMF: " + BigDecimal.valueOf((monto / 1000 * 35)));
        return (monto / 1000 * 35);
    } else {
        return 0.0;
    }
}
