package screens.actions.consulta;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import javax.imageio.ImageIO;
import javax.swing.JOptionPane;
import dav.library.common.CatTipoMovimiento;
import library.common.Util;
import library.reporting.Evidence;
import library.reporting.Reporter;
import screens.actions.common.StratusBase;
import stratus.library.common.MovimientoStratus;
import screens.actions.common.CommonStratus;

public class StratusProductos extends StratusBase {

	private String numProdCompleto = ""; // SE USA CUANDO SE TIENEN DATOS OFUSCADOS O INCOMPLETOS
	private boolean errorConsultaSaldos;
	private String tipoCtaReal = ""; // EN CONSULTAS MAESTRAS SE PUEDE INDICAR UN TIPO DE CUENTA QUE NO ES, ACÁ SE
										// GUARDA EL REAL
	// LISTA DE LA DUPLA DE MOVIMIENTOS CON SU CONTRAPARTIDA CUYO GMF NO ES
	// REVERSADO
	// POSICIÓN PAR EL MOVIMIENTO ORIGINAL - POSICIÓN IMPAR LA CONTRAPARTIDA QUE NO
	// TIENE EL GMF
	private List<MovimientoStratus> listaDuplaMovsGMFNoReversado;
//=======================================================================================================================
	// ALMACENA LAS CUENTAS ASOCIADAS A LAS CUENTAS MIGRADAS:
	// Key=TipoCta-NumCta(a16Díg), Value=CtaAsociada(a16Díg)
	private static Map<String, String> dicCtasAsoc_Migradas = new HashMap<String, String>();
	public static final int MIN_ADD_MOVS_TX = 2; // NÚMERO DE MINUTOS ADICIONALES PARA BUSCAR MOVIMIENTOS
	public static final int TAM_NUM_CTA = 16; // TAMAÑO QUE DEBE TENER LA CUENTA, PARA LAS CONSULTAS EN STRATUS
	private static final int RENG_ERROR_SALDO = 22; // RENGLÓN EN DONDE SE PRESENTAN ERRORES EN LA PANTALLA DE SALDOS
	private int RENG_PRIMER_MOV = 0; // LÍNEA DONDE SE ENCUENTRA EL PRIMER MOVIMIENTO BUSCADO
	private static final int RENG_INICIO_PRODS = 6; // LÍNEA DONDE INICIAN LOS PRODUCTOS EN [PT_CONSULTA_PORTAF_NIT]
	private static final int RENG_FIN_PRODS = 18; // LÍNEA DONDE TERMINAN LOS PRODUCTOS EN [PT_CONSULTA_PORTAF_NIT]
	private static final int RENG_INICIO_MOVS = 8; // LÍNEA DONDE INICIAN LOS MOVIMIENTOS EN [PT_CONSULTA_MOVIMIENTO]
	private static final int RENG_FIN_MOVS = 17; // LÍNEA DONDE TERMINAN LOS MOVIMIENTOS EN [PT_CONSULTA_MOVIMIENTO]
	public static final String CTA_CORRIENTE = "CC"; // Tipo de cuenta para cuenta corriente
	public static final String CTA_AHORROS = "AH"; // Tipo de cuenta para cuenta de ahorros
	public static final String CREDITO = "CRED"; // Tipo de producto para cualquier producto de crédito
	public static final String TARJETA_CREDITO = "TC"; // Tipo de producto para cualquier producto Tarjeta de crédito
	public static final String FONDO_INVERSION = "FONDO"; // Tipo de producto para cualquier producto Fondo de Inversión
	public static final String CREDITO_COBROS_PORTAF = "CREDITO COBRO PORTAFOLIO"; // para Cobros de Portafolio
	// DATO DEL PRODUCTO CUANDO SE HACE LA CONSULTA DE MOVIMIENTOS DE FORMA DIRECTA
	// EN LA PANTALLA DE CONSULTA
	public static final String MOV_CTA_CORRIENTE = "CTE"; // PARA CUENTA CORRIENTE
	public static final String MOV_CTA_AHORROSDM = "AHD"; // PARA CUENTA DE AHORROS DAMAS
	public static final String MOV_CTA_AHORROSFD = "FDH"; // PARA CUENTA DE AHORROS FD ?
	public static final String MOV_FMS = "FMS"; // PARA CREDIEXPRESS
	public static final String MOV_ADQ = "ADQ"; // PARA DAVIPLATA / TARJETA DE CREDITO
	public static final String MOV_CCS = "CCS"; // PARA TARJETAS ECARD
	public static final String MOV_OTM = "OTM"; // PARA GIROS / CÉDULAS
	public static final String MOV_DOC = "DOC"; // PARA ???
	public static final String MOV_SUM = "SUM"; // PARA ???
	public static final String MOV_DEP = "DEP"; // PARA DEPÓSITOS ELECTRÓNICOS
	private static final String[] ARR_PROD_MOVS = { MOV_FMS, MOV_ADQ, MOV_CCS, MOV_OTM, MOV_DOC, MOV_SUM, MOV_DEP,
			MOV_CTA_CORRIENTE, MOV_CTA_AHORROSDM, MOV_CTA_AHORROSFD };
//=======================================================================================================================
	// CONSTANTES DE MENSAJES
	private final int TAM_MAX_LINEA = 80;
	private final String CTA_CANCELADA = "CUENTA CANCELADA";
	private final String CTA_NO_EXISTE = "CUENTA NO EXISTE";
	private final String NO_EXISTE_REG = "NO EXISTE REGISTRO EN BUC";
	private final String CTA_NO_VIGENTE = "CUENTA NO VIGENTE OTRO MOTVO";
	private final String SIN_CONVENIO = "REF PAGO NO TIENE CONVENIO ASOCIADO";
	private final String OFI_RAD_NOEXIS = "OFICINA RECAUDO O RADICACION NO EXISTE";
	private final String TJT_NO_EXISTE = "TARJETA NO EXISTE";
	private final String TX_NO_PERMIT = "TRANSACCION NO PERMITIDA";
	// TEXTO CUANDO UNA CUENTA TIENE 15 DÍGITOS Y STRATUS LA VALIDA COMO UN CRÉDITO
	// AL COMPLETAR CON CEROS
	private final String CREDIT_NOT_EXIST = "CREDITO NO EXISTE";
	private final String CTA_NO_VIGENTE_CANCEL = "CUENTA NO VIGENTE CANCEL MASIVAS";
	private final String PROD_DESCON = "PRODUCTO DESCONOCIDO";
	// ARRAY CON LOS MENSAJES DE RROR QUE SE PYEDEN PRESENAR EN LA CONSULTA MAESTRA Y NO SE PUEDE ACCEDER A LA CTA
	private String[] MSGS_CTA_SINDATOS = { CTA_CANCELADA, CTA_NO_EXISTE, NO_EXISTE_REG, CTA_NO_VIGENTE, SIN_CONVENIO,
		OFI_RAD_NOEXIS, TJT_NO_EXISTE, TX_NO_PERMIT, CREDIT_NOT_EXIST, CTA_NO_VIGENTE_CANCEL, PROD_DESCON };
	
	private final String NO_HAY_MOVS = "POR FAVOR VERIFICAR DATOS DE CONSULTA";
	// TEXTO QUE SE PRESENTA CUANDO EN LA CONSULTA DEL SALDO DE UNA CUENTA
	// CORRIENTE, SE DEBE CONSULTAR SU CENTRALIZADORA
	private final String CENTRALIZADORA = "CONSULTE CENTRALIZADORA";
//=======================================================================================================================
	// CONSTANTES QUE IDENTIFICAN LOS TITULOS DE LAS PANTALLAS DE STRATUS PARA LAS
	// CONSULTAS DE PRODUCTOS
	private final String PT_CONSULTA_MAESTRAS = "C O N S U L T A   D E    M A E S T R A S";
	private final String PT_CONSULTA_PORTAF_NIT = "CONSULTA DE PORTAFOLIO A TRAVES DEL NIT";
	private final String PT_CONSULTA_MOVIMIENTO = "C O N S U L T A   M O V I M I E N T O";
	private final String PT_CONSULTA_SALDO_AH = "CONSULTA DE SALDOS DE CTA DE AHORROS";
	private final String PT_CONSULTA_SALDO_CC = "CONSULTA DE SALDO CUENTA CORRIENTE / CREDIPLUS";
	private final String PT_CONSULTA_SALDO_CRED = "CONSULTA PRODUCTOS DE FM";
	private final String PT_CONSULTA_SALDO_TC = "CONSULTA TARJETA CREDITO";
	private final String PT_CONSULTA_SALDO_FOND = "CONSULTA DE FONDO DE INVERSION";
	private final String PT_PARAMET_CREDIPLUS = "MODULO PARA RELACIONAR CUENTA DE DESTANQUEO DE CREDIPLUS";
	private final String PT_BANCA_EMPRESARIAL = "ADMINISTRACION DE PARAMETROS BANCA EMPRESARIAL";
	private final String PT_BLOQUEO_TRANSACC = "BLOQUEO TRANSACCIONAL";
	private final String PT_CONSULTA_PORTAFOLIOS = "ACTUALIZACION   DALIRPR";

//=======================================================================================================================
	/**
	 * Constructor que setea las credenciales de logueo, intenta abrir la sesión de
	 * Stratus, en caso de falla termina la prueba.
	 */
	public StratusProductos(String user, String password) {
		super(user, password);
	}

	/**
	 * Constructor cuya base es un BaseStratus que ya esté abierto - no vuelve a
	 * hacer la apertura
	 */
	public StratusProductos(StratusBase parent) {

		super(parent);
	}

//***********************************************************************************************************************
	/**
	 * Cuando se trata de cuentas ofuscadas, con este método <b>después</b> de haber
	 * realizado una consulta previa ya se puede saber el número completo del
	 * producto.
	 */
	public String getNumProdCompleto() {

		return numProdCompleto;
	}

	/**
	 * Usar únicamente cuando se sabe que la consulta del producto se realizo a
	 * través de la pantalla de CONSULTA DE MAESTRAS.<br>
	 * Se usa, porque aveces al hacer la consulta se puede indicar que es de ahorros
	 * pero al ingresar la cuenta, Stratus cambia el dato del tipo de cuenta
	 * indicando el valor real.
	 */
	public String getTipoCtaReal() {

		return this.tipoCtaReal;
	}

	/**
	 * Retorna lista que contienen las duplas de Movimientos que cuentan con
	 * contrapartida cuyo GMF no fue reversado.<br>
	 * Posición Par el movimiento original - Posición impar la contrapartida que no
	 * reversó el GMF.<br>
	 * Sólo se llenan con la invocación de los métodos [getMovimientosEnRango] y
	 * [getDatosYMovimientosEnRango]
	 */
	public List<MovimientoStratus> getListaDuplaMovsGMFNoReversado() {

		return this.listaDuplaMovsGMFNoReversado;
	}

//***********************************************************************************************************************
	/**
	 * Este método recibe el tipo de la cuenta y el número de la cuenta.<br>
	 * La consulta se hace en CONSULTA DE MAESTRAS, por ende son productos AH y CC
	 * (para el tipo de cuenta).<br>
	 * Consulta los saldos y los datos de la cuenta (los datos son retornados en
	 * MAYÚSCULA).
	 * 
	 * @param tipoCta       - El tipo de la cuenta : Puede ser Corriente o Ahorros
	 * @param numCta        - Número de la cuenta a consultar.
	 * @param incluirSaldos - Indica si se va a hacer consulta de saldos, en tal
	 *                      caso retorna en las primeras posiciones del array de
	 *                      retorno el 0-Saldo Disponible, el 1-Saldo Total,
	 *                      2-#CtaCentralizadora.
	 * @param datos         - Datos a buscar de la cuenta. Cada dato recibido debe
	 *                      corresponder al <b>label del dato</b> como se muestra en
	 *                      Stratus en la pantalla "C O N S U L T A D E M A E S T R
	 *                      A S".
	 * @return Retorna un arreglo de String con la información que se busca:<br>
	 *         - Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si la consulta NO retorna ERROR por ninguna consulta, retorna:<br>
	 *         * incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora (si tiene), 3..-Datos consultados<br>
	 *         * incluirSaldos = false >> 0..-Datos consultados
	 */
	public String[] getDatosCuenta(String tipoCta, String numCta, boolean incluirSaldos, String... datos)
			throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoCta); // GARANTIZA EL DATO
		String[] arrCtas = { tipoCuenta + "-" + numCta };
		List<String[]> datosCta = this.getDatosCuentas(arrCtas, incluirSaldos, datos);
		return datosCta.get(0);
	}

//***********************************************************************************************************************
	/**
	 * Este método recibe en un arreglo la información de una o más cuentas, cada
	 * elemento del arreglo contiene la información del tipo de cuenta y número de
	 * cuenta (separados por "-").<br>
	 * La consulta se hace en CONSULTA DE MAESTRAS, por ende son productos AH y CC
	 * (para el tipo de cuenta).
	 * 
	 * @param arrCtas       - Cuentas que se van a consultar, cada elemento es una
	 *                      cadena "tipoCta-numCta". Donde 'tipoCta' debe ser igual
	 *                      a <b>AH / CC</b>.
	 * @param incluirSaldos - Indica si se va a hacer consulta de saldos, en tal
	 *                      caso retorna en las primeras posiciones del array de
	 *                      retorno el 0-Saldo Disponible, el 1-Saldo Total,
	 *                      3-#CtaCentralizadora.
	 * @param datos         - Datos a buscar de la cuenta. Cada dato recibido debe
	 *                      corresponder al <b>label del dato</b> como se muestra en
	 *                      Stratus en la pantalla "C O N S U L T A D E M A E S T R
	 *                      A S".
	 * @return Retorna una Lista de String[] con la información que se busca:<br>
	 *         - Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si la consulta NO retorna ERROR por ninguna consulta, retorna: *
	 *         incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora, 3..-Datos consultados * incluirSaldos = false
	 *         >> 0..-Datos consultados
	 */
	public List<String[]> getDatosCuentas(String[] arrCtas, boolean incluirSaldos, String... datos) throws Exception {

		List<String[]> listaRetorno = new ArrayList<String[]>();
		if (arrCtas.length == 0)
			return listaRetorno; // NO HAY DATOS DE CUENTAS PARA CONSULTAR
//-----------------------------------------------------------------------------------------------------------------------
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaMaestra(); // IR A LA PANTALLA [PT_CONSULTA_MAESTRAS]
		String tipoCta, numCta, pantallaDatosCta, pantallaSaldo, lineaError, numCtaCent;
		String[] arrTemp, arrSaldos, arrDatos;
		boolean guardarEvidDatos = (datos.length > 0);
		for (String datosCta : arrCtas) {
			// EL CURSOR ESTÁ EN EL CAMPO "TIPO CTA"
			arrTemp = datosCta.split("-");
			tipoCta = arrTemp[0];
			numCta = arrTemp[1];
			pantallaDatosCta = this.ingresarDatosCta(tipoCta, numCta, guardarEvidDatos);
			if (pantallaDatosCta.length() <= TAM_MAX_LINEA) { // LA CONSULTA DE LA CUENTA PRESENTÓ ERROR
				listaRetorno.add(new String[] { pantallaDatosCta });
				continue; // PARA QUE SIGA CON EL SIGUIENTE ELEMENTO DEL [for]
			}
			// ENCONTRÓ LA INFORMACIÓN DE LA CUENTA
			tipoCta = this.tipoCtaReal; // PARA GARANTIZAR QUE TOME LA REAL
			arrSaldos = new String[0]; // INICIALIZA COMO SI NO HUBIERA SALDOS PARA INCLUIR
			if (incluirSaldos) { // HACE LA CONSULTA DE LOS SALDOS
				numCtaCent = "";
				pantallaSaldo = this.getPantallaSaldoCta(tipoCta, numCta, true);
				if (pantallaSaldo.contains(CENTRALIZADORA)) { // NO HAY SALDO Y SE DEBE CONSULTAR DE LA CENTRALIZADORA
					numCtaCent = Util.getTextoEntre(pantallaSaldo, CENTRALIZADORA, "|");
					this.ingresarDatosCta(tipoCta, numCtaCent, guardarEvidDatos);
					pantallaSaldo = this.getPantallaSaldoCta(tipoCta, numCtaCent, true);
				}
				// SI NO ENTRA A LA PANTALLA DE SALDOS, DEJA INFORMACIÓN DEL ERROR:
				if (!pantallaSaldo.toUpperCase().contains("SALDO TOTAL")) {
					lineaError = this.getLineaError(pantallaSaldo, false);
					listaRetorno.add(new String[] { lineaError });
					continue; // PARA QUE SIGA CON EL SIGUIENTE ELEMENTO DEL [for]
				}
				// ENCONTRÓ INFORMACIÓN DE SALDOS: 0-Saldo Disponible, 1-Saldo Total,
				// 2-#CtaCentralizadora
				arrSaldos = new String[3];
				arrSaldos[2] = numCtaCent;
				if (tipoCta.equals(CTA_AHORROS)) {
					arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Disponible:", "\n"),
							2);
					arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Total :", "\n"), 2);
				} else { // ES [CTA_CORRIENTE]
					arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "DISPONIBLE EFECTIVO", "|"),
							2);
					arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "SALDO TOTAL", "|"), 2);
				}
			}
			// SE ADICIONAN A LA LISTA DE RETORNO LOS DATOS DE LA CUENTA Y LOS SALDOS (SI SE
			// CONSULTARON)
			arrDatos = this.getDatosCta(pantallaDatosCta, datos);
			listaRetorno.add(Util.joinArrays(arrSaldos, arrDatos));
//-----------------------------------------------------------------------------------------------------------------------
		} // CIERRE DEL FOR
		this.returnInicio();
		return listaRetorno;
	}

//***********************************************************************************************************************
	/**
	 * El método se encarga de realizar consulta de una chequera y retornar en una
	 * lista los datos asociados a la misma. Si la variable "numeroChequera" se
	 * recibe vacía (""), se valida el listado de chequeras disponibles y se busca
	 * aquella que tenga estado activo "AC", posterior a esto, se retorna la
	 * información de la primera chequera que cumpla con esta característica.
	 * 
	 * @param tipoCuenta       - Tipo de cuenta que se va a consultar.
	 * @param numeroCuenta     - Número de cuenta que se va a consultar.
	 * @param numeroChequera   - Número de chequera que se va a consultar. Se puede
	 *                         recibir valor vacío ("").
	 * @param irPantallaInicio - Bandera para indicar si se desea regresar a la
	 *                         pantalla de inicio (true) o si se desea mantener en
	 *                         la pantalla de chequeras en caso de que se requiera
	 *                         realizar gestión sobre los cheques asignados a la
	 *                         chequera (false).
	 * @param chequeraEsCuenta - Bandera para indicar si el número de cuenta
	 *                         ingresado es el número de la chequera. Es importante
	 *                         dado que cuando se realiza consulta con el número de
	 *                         chequera, Stratus indica que la cuenta no existe pero
	 *                         con esta información se sabrá si se debe o no
	 *                         continuar el proceso. *
	 * @return Retorna una lista de String[] con la siguiente información:<br>
	 *         Número de la chequera, dígito de verificación, número de cheque
	 *         inicial, número de cheque final, estado, oficina de asignación, fecha
	 *         de asignación, oficina de activación, fecha de activación, fila donde
	 *         se encuenta ubicada la chequera y ruta de la evidencia.
	 * @return Si existen problemas en la consulta de la cuenta o con la chequera
	 *         relacionada, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 * @author : Laura N. Tinjacá
	 */
	public List<String> consultaChequera(String tipoCuenta, String numeroCuenta, String numeroChequera,
			boolean irPantallaInicio, boolean chequeraEsCuenta) throws Exception {

		List<String> listaRetorno = new ArrayList<String>();
		String mensajeConsultaCuenta, textoPantalla, textoRetorno, rutaEvidencia, tipoCta; // GARANTIZA EL DATO
		String[] arregloLineas, datosChequera;
		boolean guardarEvidenciaDatos = true, encontroChequera = false;
		tipoCta = StratusProductos.getTipoCuenta(tipoCuenta);
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaMaestra(); // IR A LA PANTALLA [PT_CONSULTA_MAESTRAS]
		mensajeConsultaCuenta = this.ingresarDatosCta(tipoCta, numeroCuenta, guardarEvidenciaDatos);
		if (!mensajeConsultaCuenta.equals("TARJETA NO EXISTE") && chequeraEsCuenta == false
				|| mensajeConsultaCuenta.equals("TARJETA NO EXISTE") && chequeraEsCuenta) {
			this.ctrlX(1);
			textoPantalla = this.read();
			textoRetorno = Util.getTextoEntre(textoPantalla, "2.", "3.");
			if (textoRetorno.contains("CHEQUES Y CHEQUERA")) {
				this.sendKey(2);
				this.ctrlX(1);
				textoPantalla = this.read();
				textoRetorno = Util.getTextoEntre(textoPantalla, "CUENTA/CHEQUERA    :", "|");
				if (Util.containsIgnoreCaseAndAccents(textoRetorno, Util.right(numeroCuenta, 12))) {
					this.ctrlX(1);
					textoPantalla = this.read();
					textoRetorno = Util.getTextoEntre(textoPantalla, "                             ",
							"     Pag 0001   de  0001");
					if (textoRetorno.contains("CONSULTA DE CHEQUERAS")) {
						rutaEvidencia = this.saveEvidence("Listado de chequeras");
						textoPantalla = this.read();
						textoRetorno = Util.getTextoEntre(textoPantalla, " NRO CHEQUERA",
								"------------------------------------------------------------------------------");
						arregloLineas = textoRetorno.split("\n");
						if (numeroChequera.equals("")) {
							for (int i = 2; i < arregloLineas.length; i++) {
								if (arregloLineas[i].contains("AC")) {
									datosChequera = arregloLineas[i].split(" ");
									for (int j = 0; j < datosChequera.length; j++) {
										if (!datosChequera[j].equals("")) {
											numeroChequera = datosChequera[j];
											break;
										}
									}
									break;
								}
							}
						}
						for (int i = 0; i < arregloLineas.length; i++) {
							if (arregloLineas[i].contains(Util.left(numeroChequera, 11))) {
								datosChequera = arregloLineas[i].split(" ");
								for (int j = 0; j < datosChequera.length; j++) {
									if (!datosChequera[j].equals(""))
										listaRetorno.add(datosChequera[j]);
								}
								encontroChequera = true;
								listaRetorno.add(String.valueOf(i + 1));
								listaRetorno.add(rutaEvidencia);
								break;
							}
						}
						if (!encontroChequera) {
							listaRetorno.add(
									"No se encontró el número de chequera indicado o no existe chequera con estado activo");
							this.escapeQ(5); // PARA DEJARLO EN LA PANTALLA INICIAL
						} else if (irPantallaInicio)
							this.escapeQ(5);
					} else {
						listaRetorno.add("Error en el proceso de consulta de chequeras");
						this.saveEvidence("Error en el proceso de consulta de chequeras");
						this.escapeQ(4);
					}
				} else {
					listaRetorno.add("Error en el proceso de consulta de chequeras");
					this.saveEvidence("Error en el proceso de consulta de chequeras");
					this.escapeQ(3);
				}
			} else {
				listaRetorno.add("Error en el proceso de consulta de chequeras");
				this.saveEvidence("Error en el proceso de consulta de chequeras");
				this.escapeQ(2);
			}
		} else {
			listaRetorno.add(mensajeConsultaCuenta);
			this.escapeQ(1);
		}
		return listaRetorno;
	}

//***********************************************************************************************************************
	/**
	 * El método se encarga de realizar consulta de la información asociada a un
	 * cheque y retornar en una lista los datos asociados al mismo. Si la variable
	 * "numeroCheque" se recibe vacía (""), se valida el listado de cheques
	 * disponibles y se busca aquel que tenga estado no pagado "NP", posterior a
	 * esto, se retorna la información del primer cheque que cumpla con esta
	 * característica. Si la variable "numeroCheque" se recibe con información, se
	 * valida el listado de cheques disponibles y se busca aquel que coincida con el
	 * dato ingresado, posterior a esto, se retorna la información del primer cheque
	 * que cumpla con esta característica.
	 * 
	 * @param tipoCuenta             - Tipo de cuenta que se va a consultar.
	 * @param numeroCuenta           - Número de cuenta que se va a consultar.
	 * @param numeroChequera         - Número de chequera que se va a consultar. Se
	 *                               puede recibir valor vacío ("").
	 * @param numeroCheque           - Número de cheque que se va a consultar. Se
	 *                               puede recibir valor vacío ("").
	 * @param consultarDetalleCheque - Bandera para indicar si se desea consultar el
	 *                               detalle del cheque o con la información
	 *                               presentada en el listado de cheques disponible
	 *                               es suficiente.
	 * @param chequeraEsCuenta       - Bandera para indicar si el número de cuenta
	 *                               ingresado es el número de la chequera. Es
	 *                               importante dado que cuando se realiza consulta
	 *                               con el número de chequera, Stratus indica que
	 *                               la cuenta no existe pero con esta información
	 *                               se sabrá si se debe o no continuar el proceso.
	 * @param numeroCheque           - Valor del cheque que se va a consultar si el
	 *                               mismo ya fue procesado o girado. En caso de que
	 *                               se quiera buscar un cheque aleatorio con estado
	 *                               NP, se puede recibir valor vacío ("").
	 * @param fechaCheque            - Fecha en que el cheque que se va a consultar
	 *                               fue procesado o girado. En caso de que se
	 *                               quiera buscar un cheque aleatorio con estado
	 *                               NP, se puede recibir valor vacío ("").
	 * @return Retorna una lista de String[] con la siguiente información si la
	 *         bandera consultarDetalleCheque es false:<br>
	 *         Número de la chequera, dígito de verificación, número de cheque
	 *         inicial, número de cheque final, estado de la chequera, oficina de
	 *         asignación de la chequera, fecha de asignación de la chequera,
	 *         oficina de activación de la chequera, fecha de activación de la
	 *         chequera, fila donde se encuenta ubicada la chequera, ruta de
	 *         evidencia de la chequera, número del cheque, estado del cheque, valor
	 *         del cheque, fecha en la cual se procesó el cheque, oficina en la cual
	 *         se procesó el cheque, fila donde se encuenta ubicado el cheque y ruta
	 *         de evidencia del cheque.
	 * @return Retorna una lista de String[] con la siguiente información si la
	 *         bandera consultarDetalleCheque es true:<br>
	 *         Número de la chequera, dígito de verificación, número de cheque
	 *         inicial, número de cheque final, estado de la chequera, oficina de
	 *         asignación de la chequera, fecha de asignación de la chequera,
	 *         oficina de activación de la chequera, fecha de activación de la
	 *         chequera, fila donde se encuenta ubicada la chequera, ruta de
	 *         evidencia de la chequera, número del cheque, estado del cheque, valor
	 *         del cheque, fecha en la cual se procesó el cheque, oficina en la cual
	 *         se procesó el cheque, fila donde se encuenta ubicado el cheque, ruta
	 *         de evidencia del cheque, valor del detalle del cheque, fecha de
	 *         detalle del cheque, oficina de detalle del cheque, estado del detalle
	 *         del cheque, nombre del beneficiario, número de cuenta giradora y NIT
	 *         girador.
	 * @return Si existen problemas en la consulta de la cuenta o con la chequera o
	 *         cheque relacionado, el String[] tendrá un único elemento que indica
	 *         el error presentado.<br>
	 * @author : Laura N. Tinjacá
	 */
	public List<String> consultaEstadoCheque(String tipoCuenta, String numeroCuenta, String numeroChequera,
			String numeroCheque, boolean consultarDetalleCheque, boolean chequeraEsCuenta, String valorCheque,
			String fechaCheque) throws Exception {

		String textoPantalla, textoRetorno, rutaEvidencia, textoContains, textoEvidencia;
		String[] arregloLineas;
		boolean encontroChequeDisponible = false;
		List<String> listaRetorno = new ArrayList<String>();
		DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols();
		decimalFormatSymbols.setDecimalSeparator('.');
		decimalFormatSymbols.setGroupingSeparator(',');
		DecimalFormat decimalFormat = new DecimalFormat("###,###.##", decimalFormatSymbols);
		listaRetorno = this.consultaChequera(tipoCuenta, numeroCuenta, numeroChequera, false, chequeraEsCuenta);
		if (listaRetorno.size() > 1) {
			this.down(Integer.parseInt(listaRetorno.get(9)) - 3);
			this.sendKey("X".charAt(0));
			this.ctrlX(1);
			textoPantalla = this.read();
			textoRetorno = Util.getTextoEntre(textoPantalla, " CHEQUE       ES            VALOR",
					" -----------------------------------------------------------------------------");
			arregloLineas = textoRetorno.split("\n");
			if (chequeraEsCuenta == false) {
				if (numeroCheque.equals("")) {
					textoContains = "NP";
					textoEvidencia = "Cheque disponible";
				} else {
					textoContains = numeroCheque;
					textoEvidencia = "Cheque pagado - reversado";
				}
				for (int i = 0; i < arregloLineas.length; i++) {
					if (arregloLineas[i].contains(textoContains)) {
						listaRetorno.add(Util.mid(arregloLineas[i], 9, 9).trim());
						listaRetorno.add(Util.mid(arregloLineas[i], 23, 2).trim());
						listaRetorno.add(Util.mid(arregloLineas[i], 27, 28).trim().replace("$", "").replace(",", "")
								.replace(".00", ""));
						listaRetorno.add(Util.mid(arregloLineas[i], 55, 4).trim());
						listaRetorno.add(Util.mid(arregloLineas[i], 64, 4).trim());
						encontroChequeDisponible = true;
						this.down(i - 1);
						rutaEvidencia = this.saveEvidence(textoEvidencia);
						listaRetorno.add(String.valueOf(i + 1));
						listaRetorno.add(rutaEvidencia);
						break;
					}
				}
			} else {
				if (numeroCheque.equals("")) {
					textoContains = "GR";
					textoEvidencia = "Cheque girado";
				} else {
					textoContains = numeroCheque;
					textoEvidencia = "Cheque pagado";
				}
				for (int i = 0; i < arregloLineas.length; i++) {
					if (textoContains.equals("GR")) {
						if (arregloLineas[i].contains(textoContains)
								&& arregloLineas[i].contains(decimalFormat.format(Double.parseDouble(valorCheque)))
								&& arregloLineas[i].contains(fechaCheque)) {
							listaRetorno.add(Util.mid(arregloLineas[i], 9, 9).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 23, 2).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 27, 28).trim().replace("$", "").replace(",", "")
									.replace(".00", ""));
							listaRetorno.add(Util.mid(arregloLineas[i], 55, 4).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 64, 4).trim());
							encontroChequeDisponible = true;
							this.down(i - 1);
							rutaEvidencia = this.saveEvidence(textoEvidencia);
							listaRetorno.add(String.valueOf(i + 1));
							listaRetorno.add(rutaEvidencia);
							break;
						}
					} else {
						if (arregloLineas[i].contains(textoContains)) {
							listaRetorno.add(Util.mid(arregloLineas[i], 9, 9).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 23, 2).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 27, 28).trim().replace("$", "").replace(",", "")
									.replace(".00", ""));
							listaRetorno.add(Util.mid(arregloLineas[i], 55, 4).trim());
							listaRetorno.add(Util.mid(arregloLineas[i], 64, 4).trim());
							encontroChequeDisponible = true;
							this.down(i - 1);
							rutaEvidencia = this.saveEvidence(textoEvidencia);
							listaRetorno.add(String.valueOf(i + 1));
							listaRetorno.add(rutaEvidencia);
							break;
						}
					}
				}
			}
			if (consultarDetalleCheque && encontroChequeDisponible) {
				this.ctrlX(3);
				textoPantalla = this.read();
				arregloLineas = textoPantalla.split("\n");
				this.saveEvidence("Detalle del cheque");
				listaRetorno.add(Util.mid(arregloLineas[13], 40, 21).trim());
				listaRetorno.add(Util.mid(arregloLineas[14], 20, 8).trim());
				listaRetorno.add(Util.mid(arregloLineas[14], 29, 4).trim());
				listaRetorno.add(Util.mid(arregloLineas[14], 34, 20).trim());
				listaRetorno.add(Util.mid(arregloLineas[15], 33, 29).trim());
				listaRetorno.add(Util.mid(arregloLineas[16], 35, 27).trim());
				listaRetorno.add(Util.mid(arregloLineas[17], 35, 27).trim());
			}
			if (!encontroChequeDisponible) {
				listaRetorno.clear();
				listaRetorno.add("No se encontró un número de cheque disponible");
				this.saveEvidence("No se encontró un número de cheque disponible");
				this.escapeQ(5); // PARA DEJARLO EN LA PANTALLA INICIAL
			} else
				this.escapeQ(6);
		} else
			return listaRetorno;
		return listaRetorno;
	}

//***********************************************************************************************************************
	/**
	 * Este método requiere el tipo y número de documento del cliente al que
	 * corresponde la cuenta.<br>
	 * Se recibe el tipo de la cuenta y el número de la cuenta, el número de cuenta
	 * viene ofuscado, es decir que sólo se conocen los últimos 4 dígitos de la
	 * cuenta.<br>
	 * La consulta se hace desde "CONSULTA DE PORTAFOLIO A TRAVES DEL NIT" y luego
	 * se dirige a la consulta de la cuenta, por ende se esperan productos de tipo
	 * Ahorro o Corriente.
	 * 
	 * @param tipoDocumento - Tipo de documento del cliente dueño de la cuenta.
	 * @param numeroDoc     - Número de documento del cliente dueño de la cuenta.
	 * @param tipoCuenta    - El tipo de la cuenta : Puede ser Corriente o Ahorros
	 * @param numCta        - Número de la cuenta a consultar, se encuentra
	 *                      ofuscado, se toman sólo los últimos 4 dígitos.
	 * @param incluirSaldos - Indica si se va a hacer consulta de saldos, en tal
	 *                      caso retorna en las primeras posiciones del array de
	 *                      retorno el 0-Saldo Disponible, el 1-Saldo Total,
	 *                      3-#CtaCentralizadora.
	 * @param datos         - Datos a buscar de la cuenta. Cada dato recibido debe
	 *                      corresponder al <b>label del dato</b> como se muestra en
	 *                      Stratus en la pantalla "C O N S U L T A D E M A E S T R
	 *                      A S".
	 * @return Retorna una Lista de String[] con la información que se busca:<br>
	 *         - Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         - Si la consulta NO retorna ERROR por ninguna consulta, retorna:<br>
	 *         * incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora, 3..-Datos consultados<br>
	 *         * incluirSaldos = false >> 0..-Datos consultados
	 */
	public String[] getDatosCuentaOfuscada(String tipoDocumento, String numeroDoc, String tipoCuenta, String numCta,
			boolean incluirSaldos, String... datos) throws Exception {

		String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(tipoDocumento); // GARANTIZA EL DATO
		String tipoCta = StratusProductos.getTipoCuenta(tipoCuenta); // GARANTIZA EL DATO
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaPortafolio(); // IR A LA PANTALLA [PT_CONSULTA_PORTAF_NIT]
		boolean desdeConsMaestra = false; // LA CONSULTA DEL SALDO NO SE HACE DESDE CONSULTA MAESTRA
		// 0:Error, 1:Pantalla
		String[] arrCursorEnProd = this.ubicarCursorEnProducto(tipoDoc, numeroDoc, tipoCta, numCta, true);
		if (!arrCursorEnProd[0].isEmpty()) {
			this.returnInicio();
			return new String[] { arrCursorEnProd[0] };
		}
		// ENCONTRÓ EL PRODUCTO
		String pantallaDatosCta = arrCursorEnProd[1];
		boolean estaEnDatos = !pantallaDatosCta.isEmpty();
		boolean guardarEvidDatos = (datos.length > 0);
//-----------------------------------------------------------------------------------------------------------------------
		String lineaError;
		if (datos.length == 0) // NO REQUIERE CONSULTA DE LOS DATOS
			desdeConsMaestra = estaEnDatos; // NO VACÍO = EN CONSULTA MAESTRAS
		else { // SE REQUIERE LA CONSULTA DEL PRODUCTO
			if (arrCursorEnProd[1].isEmpty()) {
				this.ctrlX(2); // F2 - DATOS
				pantallaDatosCta = this.read();
				estaEnDatos = true; // SE CAMBIA PORQUE SE INGRESÓ A LOS DATOS
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// CUANDO SE TRATE DE UNA CUENTA MIGRADA SE EXTRAE EL DATO DE LA CTA ASOCIADA
				boolean esMigrada = (tipoCta.equals(CTA_AHORROS) || tipoCta.equals(CTA_CORRIENTE))
						&& esCuentaMigrada(this.numProdCompleto);
				if (esMigrada) { // MIRA SI ALMACENA LA CUENTA MIGRADA AL MAP [dicCtasAsoc_Migradas]
					String keyDic = tipoCta + "-" + this.numProdCompleto;
					if (!dicCtasAsoc_Migradas.containsKey(keyDic))
						dicCtasAsoc_Migradas.put(keyDic,
								Util.getTextoEntre(pantallaDatosCta, "DATOS PERSONALES DEL PRODUCTO :", "NIT"));
				}
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			}
			this.saveEvidence("DatosCta-" + tipoCta + this.numProdCompleto);
			lineaError = this.getLineaError(pantallaDatosCta, true); // ERROR GENERAL
			int posMsgError = Util.posItemContainsAnyArrayItem(lineaError, MSGS_CTA_SINDATOS);
			if (posMsgError != -1) { // LA CONSULTA DE LA CUENTA PRESENTÓ UNO DE LOS ERRORES [MSGS_CTA_SINDATOS]
				this.escapeQ(1); // ESTÁ EN CONSULTA MAESTRA : RETORNA A LA PANTALLA [PT_CONSULTA_PORTAF_NIT]
				this.returnInicio();
				return new String[] { MSGS_CTA_SINDATOS[posMsgError] };
			}
			desdeConsMaestra = true; // LA CONSULTA DEL SALDO SE HACE DESDE CONSULTA MAESTRA
		}
//-----------------------------------------------------------------------------------------------------------------------
		String pantallaSaldo;
		String[] arrSaldos = new String[0]; // INICIALIZA COMO SI NO HUBIERA SALDOS PARA INCLUIR
		if (incluirSaldos) { // HACE LA CONSULTA DE LOS SALDOS
			String numCtaCent = "";
			pantallaSaldo = this.getPantallaSaldoCta(tipoCta, this.numProdCompleto, desdeConsMaestra);
			if (pantallaSaldo.contains(CENTRALIZADORA)) { // NO HAY SALDO Y SE DEBE CONSULTAR DE LA CENTRALIZADORA
				numCtaCent = Util.getTextoEntre(pantallaSaldo, CENTRALIZADORA, "|");
				if (!desdeConsMaestra)
					this.ctrlX(2); // F2 - DATOS
				this.ingresarDatosCta(tipoCta, numCtaCent, guardarEvidDatos);
				pantallaSaldo = this.getPantallaSaldoCta(tipoCta, numCtaCent, true);
				this.escapeQ(1); // PARA DEJAR PANTALLA EN CONSULTA DE PORTAFOLIO
				estaEnDatos = false;
			}
			// SI NO ENTRA A LA PANTALLA DE SALDOS, DEJA INFORMACIÓN DEL ERROR:
			if (!pantallaSaldo.toUpperCase().contains("SALDO TOTAL")) {
				if (pantallaSaldo.contains(PT_CONSULTA_PORTAF_NIT))
					lineaError = this.getLineaError(pantallaSaldo, true); // ERROR GENERAL
				else
					lineaError = this.getLineaError(pantallaSaldo, false); // ERROR EN PANTALLA SALDO
				if (estaEnDatos)
					this.escapeQ(1); // RETORNA A LA PANTALLA [PT_CONSULTA_PORTAF_NIT]
				this.returnInicio();
				return new String[] { lineaError };
			}
			// ENCONTRÓ INFORMACIÓN DE SALDOS: 0-Saldo Disponible, 1-Saldo Total,
			// 2-#CtaCentralizadora
			arrSaldos = new String[3];
			arrSaldos[2] = numCtaCent;
			if (tipoCta.equals(CTA_AHORROS)) {
				arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Disponible:", "\n"), 2);
				arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Total :", "\n"), 2);
			} else { // ES [CTA_CORRIENTE]
				arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "DISPONIBLE EFECTIVO", "|"), 2);
				arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "SALDO TOTAL", "|"), 2);
			}
		}
//-----------------------------------------------------------------------------------------------------------------------
		if (estaEnDatos)
			this.escapeQ(1);
		this.returnInicio();
		// SE RETORNAN LOS DATOS DE LA CUENTA (LOS CONSULTADOS) Y LOS SALDOS (SI SE
		// CONSULTARON)
		String[] arrDatos = this.getDatosCta(pantallaDatosCta, datos);
		return Util.joinArrays(arrSaldos, arrDatos);
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un String[] los datos presentados en la consulta del saldo del
	 * producto [tipoProd] y [numProd]. En caso que haya problema con la consulta
	 * del saldo o del mismo producto, el arreglo de retorno contendrá un único
	 * elemento que dirá el error presentado.
	 * <p>
	 * Si se encuentran los saldos:<br>
	 * <b>CTA_AHORROS</b><br>
	 * 0-Saldo total, 1-Saldo disponible, 2-Canje local, 3-Canje plaza, 4-Saldo
	 * embargado, 5-Saldo bolsillos. <br>
	 * <b>CTA_CORRIENTE</b><br>
	 * 0-Saldo Disponible, 1-Canje Local, 2-Canje plaza, 3-Disponible sobregiro,
	 * 4-Interes sobregiro causado, 5-Días en sobregiro, 6-Saldo Total, 7-Remesas
	 * negociadas, 8-Disponible remesas, 9-Saldo embargado. <br>
	 * <b>CREDITO</b><br>
	 * 0-dias mora, 1-fecha saldo (dd/mm/aaaa), 2-valor saldo, 3-fecha mora
	 * (dd/mm/aaaa), 4-valor mora, 5-fecha cuota (dd/mm/aaaa), 6-valor cuota,
	 * 7-valor cupo disponible, 8-valor pago por aplicar. <br>
	 * <b>TARJETA_CREDITO</b><br>
	 * 0-Cupo Disponible, 1-Disponible avance, 2-Pago total cartera, 3-Pago mínimo
	 * cartera, 4-Saldo cubrir mora, 5-Cuotas en mora, 6-Davipuntos vigentes, 7-
	 * Fecha corte (aaaa/mm/dd), 8-Fecha límite pago (aaaa/mm/dd), 9-Estado, 10-Pago
	 * total cartera dólares, 11-Pago Minimo Cartera Dolares <br>
	 * <b>FONDO_INVERSION</b><br>
	 * 0-Fecha de apertura (dd/mm/aaaa), 1-Saldo total, 2-Saldo disponible para
	 * cancelación, 3-Saldo disponible para retiro, 4-Saldo disponible para
	 * programar, 5-Valor en canje, 6-Fecha 1er aporte (dd/mm/aaaa), 7-Monto de
	 * apertura, 8-Cta. debito auto
	 */
	public String[] getDatosPantallaSaldos(String tipoDocumento, String numeroDoc, String tipoProducto, String numProd)
			throws Exception {

		String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(tipoDocumento); // GARANTIZA EL DATO
		String tipoProd = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// SE PUEDE HACER LA CONSULTA DEL SALDO DESDE [PT_CONSULTA_MAESTRAS] SI SE TRATA
		// DE UNA CUENTA DE AHORROS O
		// CORRIENTE, Y SU NÚMERO DE CUENTA NO ESTÁ OFUSCADO
		boolean desdeConsMaestra = ((tipoProd.equals(CTA_AHORROS) || tipoProd.equals(CTA_CORRIENTE))
				&& numProd.length() > 4 && !numProd.contains("*"));
		boolean estaEnDatos = false;
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		if (desdeConsMaestra) {
			this.irConsultaMaestra();
			String pantallaDatosCta = this.ingresarDatosCta(tipoProd, numProd, true);
			if (pantallaDatosCta.length() <= TAM_MAX_LINEA) { // LA CONSULTA DE LA CUENTA PRESENTÓ ERROR
				this.returnInicio();
				return new String[] { pantallaDatosCta };
			}
			tipoProd = this.tipoCtaReal; // PARA GARANTIZAR QUE TOME LA REAL
		} else {
			this.irConsultaPortafolio(); // IR A LA PANTALLA [PT_CONSULTA_PORTAF_NIT]
			// 0:Error, 1:Pantalla de Datos de la cuenta, si se ingreso por [F2 - DATOS]
			String[] arrCursorEnProd = this.ubicarCursorEnProducto(tipoDoc, numeroDoc, tipoProd, numProd, true);
			if (!arrCursorEnProd[0].isEmpty()) {
				this.returnInicio(); // DEJA A STRATUS EN EL MENÚ INICIAL
				return new String[] { arrCursorEnProd[0] };
			}
			estaEnDatos = !arrCursorEnProd[1].isEmpty();
			// ENCONTRÓ EL PRODUCTO
		}
		// ENCONTRÓ EL PRODUCTO SE INGRESA A LA OPCIÓN DE CONSULTA DEL SALDO
		String pantallaSaldo = this.getPantallaSaldoCta(tipoProd, this.numProdCompleto, desdeConsMaestra);
		// DEJA A STRATUS EN EL MENÚ INICIAL
		if (desdeConsMaestra)
			this.returnInicio();
		else {
			if (estaEnDatos)
				this.escapeQ(1); // RETORNA A LA PANTALLA [PT_CONSULTA_PORTAF_NIT]
			this.returnInicio();
		}
		// SALIÓ MENSAJE QUE DICE QUE DEBE CONSULTAR SALDO DE LA CENTRALIZADORA
		if (pantallaSaldo.contains(CENTRALIZADORA))
			return new String[] { CENTRALIZADORA };
		// SI NO ENCUENTRA EL DATO DE SALDO TOTAL, ES PORQUE HAY ERROR
		boolean isGeneralError;
		String upperPantSaldo = pantallaSaldo.toUpperCase();
		if (!upperPantSaldo.contains("SALDO TOTAL") && !upperPantSaldo.contains("DISPONIBLE")) {
			isGeneralError = false;
			if (pantallaSaldo.contains(PT_CONSULTA_PORTAF_NIT))
				isGeneralError = true;
			return new String[] { this.getLineaError(pantallaSaldo, isGeneralError) };
		}
		// ENCONTRÓ INFORMACIÓN DE SALDOS
		String[] infoSaldos = this.getDatosPantallaSaldos(pantallaSaldo, tipoProd);
		return infoSaldos;
	}

//***********************************************************************************************************************
	/**
	 * Este método retorna en un arreglo de 2 posiciones el tipo de cuenta y número
	 * de cuenta, de la cuenta de cobro que está parametrizada en Stratus para una
	 * cuenta crediplus.
	 * 
	 * @param numProducto - Número del crediplus (existente)
	 * @return String[] con la información de la cuenta de cobro:<br>
	 *         - Pos 0 : Tipo de Cta cobro (como lo requiere Stratus para consultas
	 *         de saldos)<br>
	 *         - Pos 1 : Número de cta de cobro
	 */
	public String[] getCtaCobroCrediplus(String numProducto) throws Exception {

		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irParametrizacionCrediplus();
		// INGRESAR LA INFORMACIÓN PARA REALIZAR LA CONSULTA
		this.paste(numProducto);
		this.enter();
		String textoPantalla = this.read();
		String lineaCtaCobro = Util.getTextoEntre(textoPantalla, "CUENTA COBRO", "|");
		String numCtaCobro = Util.getTextoEntre(lineaCtaCobro, ":", "TIPO CUENTA");
		String tipoCtaTemp = Util.getTextoEntre(lineaCtaCobro, "TIPO CUENTA", "|");
		this.saveEvidence("CtaCobroCrediplus");
		// SE DEJA EL TIPO DE LA CUENTA COBRO COMO LA REQUIERE STRATUS PARA LAS
		// CONSULTAS DE SALDOS Y DEMÁS
		String tipoCtaCobro = CTA_CORRIENTE;
		if (tipoCtaTemp.contains("AHORRO"))
			tipoCtaCobro = CTA_AHORROS;
		this.returnInicio(); // RETORNA A LA PANTALLA DE INICIO
		String[] ctaCobro = { tipoCtaCobro, numCtaCobro };
		return ctaCobro;
	}

//***********************************************************************************************************************
	/**
	 * Se hace la consulta de TODOS los productos de un cliente dado.
	 * 
	 * @param tipoDoc   - El tipo de documento del cliente
	 * @param numeroDoc - El número del documento del cliente
	 * @return Lista de String con los números de los productos asociados al
	 *         cliente. Si no tiene productos o hay error con el cliente, el retorno
	 *         es una lista vacía.
	 */
	public List<String> getProductosCliente(String tipoDoc, String numeroDoc) throws Exception {

		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaPortafolio();
		// INGRESA LOS DATOS DE CONSULTA
		String[] arrayLinea = this.ingresarDatosConsPortafolio(tipoDoc, numeroDoc, false);
		if (arrayLinea.length == 1)
			return new ArrayList<>();
		// ENCONTRÓ PRODUCTOS, SE EMPIEZAN A ALMACENAR
		int[] arrPosProd = { 9, 33, 57 }; // POSICIONES DONDE EMPIEZA EL NÚMERO DE CADA PRODUCTO
		String numProducto;
		boolean terminar = false;
		List<String> listaProductos = new ArrayList<>();
		int numPantalla = 1;
		do {
			Evidence.save("ProductosCliente(Pant" + (numPantalla++) + ")", this);
			// RECORRE LOS PRODUCTOS ENCONTRADOS DESDE EL RENGLON DONDE INICIAN, HASTA DONDE
			// TERMINAN, DE 2 EN 2
			for (int renglon = RENG_INICIO_PRODS; renglon <= RENG_FIN_PRODS; renglon += 2) {
				// POR CADA LÍNEA MIRA QUE EXISTA UN PRODUCTO Y SI EXISTE LO ALMACENA
				for (int posArr = 0; posArr < arrPosProd.length; posArr++) {
					numProducto = Util.mid(arrayLinea[renglon], arrPosProd[posArr], TAM_NUM_CTA).trim();
					if (!numProducto.isEmpty())
						listaProductos.add(numProducto);
					else {
						terminar = true; // YA NO HAY MÁS PRODUCTOS
						break;
					}
				}
				if (terminar)
					break; // YA NO HAY MÁS PRODUCTOS
			}
			if (!terminar) { // PUEDEN HABER MÁS PRODUCTOS, SE AVANZA EN LA PÁGINA
				this.ctrlX(6); // F6 - AV PAG
				Util.wait(1);
				arrayLinea = this.read().split("\n"); // Enter
			}
		} while (!terminar);
		this.returnInicio();
		return listaProductos;
	}

//***********************************************************************************************************************
	/**
	 * Se hace la consulta del número de producto indicado por parámetro de entrada
	 * asociado al número de documento del cliente indicado.
	 * 
	 * @param tipoDoc        - Tipo de documento del cliente.
	 * @param numeroDoc      - Número del documento del cliente.
	 * @param numeroProducto - Número del producto que se desea buscar.
	 * @return Booleano con valor <true> si el número de producto indicado existe en
	 *         el listado de productos asociados al usuario o <false> si el número
	 *         de producto indicado no existe en el listado de productos asociados
	 *         al usuario.
	 */
	public boolean buscarProductoCliente(String tipoDoc, String numeroDoc, String numeroProducto) throws Exception {

		int[] arrPosProd = { 9, 33, 57 }; // POSICIONES DONDE EMPIEZA EL NÚMERO DE CADA PRODUCTO
		String numProducto;
		boolean productoExiste = false, terminarCiclo = false;
		int numPantalla = 1;
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaPortafolio();
		// INGRESA LOS DATOS DE CONSULTA
		String[] arrayLinea = this.ingresarDatosConsPortafolio(tipoDoc, numeroDoc, false);
		if (arrayLinea.length == 1)
			return false;
		// ENCONTRÓ PRODUCTOS, SE EMPIEZA A VALIDAR
		do {
			Evidence.saveTemp("Productos cliente (Pantalla " + (numPantalla++) + ")", this);
			for (int renglon = RENG_INICIO_PRODS; renglon <= RENG_FIN_PRODS; renglon += 2) {
				for (int posArr = 0; posArr < arrPosProd.length; posArr++) {
					numProducto = Util.mid(arrayLinea[renglon], arrPosProd[posArr], TAM_NUM_CTA).trim();
					if (numProducto.equals(numeroProducto)) {
						productoExiste = true;
						marcarStratusEvidence(
								Evidence.save("Número de producto '" + numeroProducto + "' encontrado", this), posArr,
								renglon);
						Evidence.cleanTempEvidence(false);
					} else if (numProducto.isEmpty()) {
						terminarCiclo = true; // YA NO HAY MÁS PRODUCTOS
						break;
					}
				}
				if (productoExiste || terminarCiclo)
					break;
			}
			if (!productoExiste && !terminarCiclo) { // PUEDEN HABER MÁS PRODUCTOS, SE AVANZA EN LA PÁGINA
				this.ctrlX(6); // F6 - AV PAG
				Util.wait(1);
				arrayLinea = this.read().split("\n");
			}
		} while (!productoExiste && !terminarCiclo);
		if (!productoExiste)
			Evidence.cleanTempEvidence(true);
		this.returnInicio();
		return productoExiste;
	}

//***********************************************************************************************************************
	/**
	 * Este método toma la evidencia de una pantalla stratus cuyo nombre con path y
	 * extensión es [pathNbEvidenceStr] y marca en ella la columna donde se
	 * encuentra el producto [columnaProducto] y el renglón indicado en
	 * [renglonAMarcar]. Después de marcada la evidencia, no se puede desmarcar.
	 * 
	 * @param pathNbEvidenceStr - Ruta y nombre de la evidencia
	 * @param columnaProducto   - Columna en la que se encuentra ubicado el producto
	 *                          <0>, <1> o <2>
	 * @param renglonAMarcar    - Renglón de Stratus. Inicia desde cero (0).
	 */
	private static void marcarStratusEvidence(String pathNbEvidenceStr, int columnaProducto, int renglonAMarcar) {

		try {
			// CARGAR LA EVIDENCE QUE SE DESEA MODIFICAR
			BufferedImage originalImage = ImageIO.read(new File(pathNbEvidenceStr));
			int ancho = originalImage.getWidth();
			int alto = originalImage.getHeight();
			// CARGA LA IMAGEN ORIGINAL
			Graphics graphics = originalImage.createGraphics();
			// EL ALTO DEL HEADER DE PUTTY ESTÁ EN [HEIGHT_BARRA] - NO SE CUENTA EL FOOTER
			int espacioStr = alto - HEIGHT_BARRA; // ESPACIO NEGRO DE STRATUS
			// LA PANTALLA ESTÁNDAR DE STRATUS MUESTRA 24 RENGLONES: CON ESE VALOR CALCULA
			// EL ALTO DE CADA RENGLON
			int altoRenglon = espacioStr / 24;
			graphics.setColor(Color.RED); // COLOR DEL MARCO SERÁ ROJO
			ancho = ancho / 3;
			int renglon = 0;
			int posInicioColumnaCero = 50;
			int posInicioColumnaUno = 25;
			double porcentaje = (30.0 / 100.0) * ancho;
			int porcentajeEvidencia = (int) porcentaje;
			for (int y = HEIGHT_BARRA + 3; y < alto - 5; y += altoRenglon) {
				if (renglon == renglonAMarcar) {
					// AGREGAR EL MARCO DE COLOR EN EL NÚMERO DE PRODUCTO DE LA IMAGEN STRATUS
					if (columnaProducto == 0)
						graphics.drawRect(columnaProducto * ancho + posInicioColumnaCero, y,
								ancho - porcentajeEvidencia, altoRenglon);
					if (columnaProducto == 1)
						graphics.drawRect(columnaProducto * ancho + posInicioColumnaUno, y, ancho - porcentajeEvidencia,
								altoRenglon);
					if (columnaProducto == 2)
						graphics.drawRect(columnaProducto * ancho, y, ancho - porcentajeEvidencia, altoRenglon);
				}
				renglon++;
			}
			// SOBREESCRIBE LA EVIDENCIA
			ImageIO.write(originalImage, "png", new File(pathNbEvidenceStr));
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

//***********************************************************************************************************************
	/**
	 * Este método se usa para ingresar al módulo que permite realizar desbloquéo
	 * transaccional y realizarlo a cada una d elas cuentas recibidas en el
	 * parámetro 'arrCtas'.
	 * 
	 * @param arrCtas - Cuentas que se van a consultar, cada elemento es una cadena
	 *                "tipoCta-numCta". Donde el tipoCta cuenta con valor
	 *                StratusProductos.CTA_AHORROS / StratusProductos.CTA_CORRIENTE.
	 */
	public void limpiarBloqueoTransaccional(String[] arrCtas) throws Exception {

		if (arrCtas.length == 0)
			return; // NO HAY DATOS DE CUENTAS PARA DESBLOQUEAR
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irBloqueoTransaccionalxCuenta();
		String[] arrTemp;
		String tipoCta, numCta;
		for (String datosCta : arrCtas) {
			arrTemp = datosCta.split("-");
			tipoCta = arrTemp[0];
			numCta = arrTemp[1];
			// SE GARANTIZA EL TAMAÑO DE LA CUENTA, PARA QUE RELLENE LOS 16 DÍGITOS
			// REQUERIDOS POR EL CAMPO
			if (numCta.length() != TAM_NUM_CTA)
				numCta = Util.leftComplete(arrTemp[1], TAM_NUM_CTA, '0');
			// EL CURSOR ESTÁ EN EL CAMPO "TIPO CUENTA"
			this.sendKey(tipoCta.charAt(0)); // INGRESA LA PRIMERA LETRA DEL TIPO DE CUENTA
			this.tab(1);
			this.paste(numCta); // PEGA EL NÚMERO DE LA CUENTA
			this.ctrlXE(); // CONSULTA LA CUENTA Y DEJA EL CURSOR EN EL CAMPO "TIPO CUENTA"
			this.saveEvidence("BloqTx " + tipoCta + numCta);
			this.ctrlX(2); // ACCIÓN QUE REALIZA EL DESBLOQUEO EXISTENTE - MANTIENE EL CURSOR EN TIPO DE
							// CUENTA
			this.saveEvidence("DesbloqTx " + tipoCta + numCta);
		}
		this.returnInicio();
	}

//***********************************************************************************************************************
	/**
	 * Retorna la lista de movimientos [MovimientoStratus] NO cancelados, que
	 * correspondan a una transacción (es decir sólo NOTA_CREDITO o NOTA_DEBITO)
	 * existentes desde una [fechaHoraTx] hasta los [minutosAdd] minutos después,
	 * <b>NO incluye movimientos que cuenten con contrapartida</b>, al tener
	 * contrapartida es como si NO se hubiera hecho.
	 * 
	 * @param tipoProducto - Tipo del producto, puede ser AH / CC / TARJETA_CREDITO
	 * @param numProducto  - Número del producto
	 * @param arrayVents   - Arreglo con los "VENT" a tener en cuenta para la
	 *                     consulta. En este arreglo NO debe incluirse el VENT
	 *                     inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaHoraTx  - Date que contiene la fecha y hora de consulta inicial.
	 * @param minutosAdd   - Número de minutos a adicionar a la hora inicial.
	 * @param datosTitular - Tipo de documento y número de documento del titular del
	 *                     producto al que se le consultan los movimientos, estos
	 *                     datos son requeridos cuando el producto NO es cuenta de
	 *                     ahorros ni corriente, porque la búsqueda se hace por
	 *                     consulta por [PT_CONSULTA_PORTAF_NIT].
	 * @return Lista con todos los movimientos DEBITO y CRÉDITO, si no hay
	 *         movimientos el retorno es una lista vacía.
	 */
	public List<MovimientoStratus> getMovimientosEnRango(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaHoraTx, int minutosAdd, String... datosTitular) throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// ALISTA EL ARREGLO DE FECHA Y HORAS A BUSCAR
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiHoraMov(fechaHoraTx, minutosAdd);
		List<MovimientoStratus> totalMovs = this.getMovimientos(tipoCuenta, numProducto, arrayVents, fechaHoraTx,
				arrFechaHora, true, datosTitular);
		List<MovimientoStratus> movsRet = new ArrayList<MovimientoStratus>();
		// INICIALIZA LA LISTA DE DUPLAS DE MOVIMIENTOS CONTRAPARTIDA CON GMF NO
		// REVERSADO
		listaDuplaMovsGMFNoReversado = new ArrayList<MovimientoStratus>();
		for (MovimientoStratus movimiento : totalMovs) {
			this.adicionarMovimientoTx(movsRet, movimiento, true); // true = EXCLUIR CONTRAPARTIDAS
		}
		return movsRet;
	}

//***********************************************************************************************************************
	/**
	 * Retorna la lista de movimientos [MovimientoStratus] NO cancelados, que
	 * correspondan a una transacción (es decir sólo NOTA_CREDITO o NOTA_DEBITO)
	 * existentes desde una [fechaHoraTx] hasta los [minutosAdd] minutos después,
	 * <b>SÍ incluye movimientos que cuentan con contrapartida</b>.
	 * 
	 * @param tipoProducto - Tipo del producto, puede ser AH / CC / TARJETA_CREDITO
	 * @param numProducto  - Número del producto
	 * @param arrayVents   - Arreglo con los "VENT" a tener en cuenta para la
	 *                     consulta. En este arreglo NO debe incluirse el VENT
	 *                     inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaHoraTx  - Date que contiene la fecha y hora de consulta inicial.
	 * @param minutosAdd   - Número de minutos a adicionar a la hora inicial.
	 * @param datosTitular - Tipo de documento y número de documento del titular del
	 *                     producto al que se le consultan los movimientos, estos
	 *                     datos son requeridos cuando el producto NO es cuenta de
	 *                     ahorros ni corriente, porque la búsqueda se hace por
	 *                     consulta por [PT_CONSULTA_PORTAF_NIT].
	 * @return Lista con todos los movimientos DEBITO y CRÉDITO, si no hay
	 *         movimientos el retorno es una lista vacía.
	 */
	public List<MovimientoStratus> getAllMovimientosEnRango(String tipoProducto, String numProducto,
			String[] arrayVents, Date fechaHoraTx, int minutosAdd, String... datosTitular) throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// ALISTA EL ARREGLO DE FECHA Y HORAS A BUSCAR
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiHoraMov(fechaHoraTx, minutosAdd);
		List<MovimientoStratus> totalMovs = this.getMovimientos(tipoCuenta, numProducto, arrayVents, fechaHoraTx,
				arrFechaHora, true, datosTitular);
		List<MovimientoStratus> movsRet = new ArrayList<MovimientoStratus>();
		// INICIALIZA LA LISTA DE DUPLAS DE MOVIMIENTOS CONTRAPARTIDA CON GMF NO
		// REVERSADO (PARA DEJARLA EN VACÍO)
		listaDuplaMovsGMFNoReversado = new ArrayList<MovimientoStratus>();
		for (MovimientoStratus movimiento : totalMovs) {
			this.adicionarMovimientoTx(movsRet, movimiento, false); // false = INCLUIR CONTRAPARTIDAS
		}
		return movsRet;
	}

//***********************************************************************************************************************
	/**
	 * Retorna la lista de movimientos [MovimientoStratus] NO cancelados, que
	 * correspondan a una transacción (es decir sólo NOTA_CREDITO o NOTA_DEBITO)
	 * existentes desde una [fechaHoraTx] hasta los [minutosAdd] minutos después,
	 * <b>NO incluye movimientos que cuenten con contrapartida</b>, ya que al tener
	 * contrapartida es como si NO se hubiera hecho.
	 * 
	 * @param tipoProducto   - Tipo del producto, puede ser AH / CC /
	 *                       TARJETA_CREDITO
	 * @param numProducto    - Número del producto
	 * @param arrayVents     - Arreglo con los "VENT" a tener en cuenta para la
	 *                       consulta. En este arreglo NO debe incluirse el VENT
	 *                       inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaHoraTx    - Date que contiene la fecha y hora de consulta
	 *                       inicial.
	 * @param minutosAdd     - Número de minutos a adicionar a la hora inicial.
	 * @param isMovCancelado - Para que retorne movimientos cancelados y poder
	 *                       validar reversiones de los créditos.
	 * @param datosTitular   - Tipo de documento y número de documento del titular
	 *                       del producto al que se le consultan los movimientos,
	 *                       estos datos son requeridos cuando el producto NO es
	 *                       cuenta de ahorros ni corriente, porque la búsqueda se
	 *                       hace por consulta por [PT_CONSULTA_PORTAF_NIT].
	 * @return Lista con todos los movimientos DEBITO y CRÉDITO, si no hay
	 *         movimientos el retorno es una lista vacía.
	 */
	public List<MovimientoStratus> getMovimientosEnRango(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaHoraTx, int minutosAdd, boolean isMovCancelado, String... datosTitular) throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// ALISTA EL ARREGLO DE FECHA Y HORAS A BUSCAR
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiHoraMov(fechaHoraTx, minutosAdd);
		List<MovimientoStratus> totalMovs = this.getMovimientos(tipoCuenta, numProducto, arrayVents, fechaHoraTx,
				arrFechaHora, isMovCancelado, datosTitular);
		List<MovimientoStratus> movsRet = new ArrayList<MovimientoStratus>();
		// INICIALIZA LA LISTA DE DUPLAS DE MOVIMIENTOS CONTRAPARTIDA CON GMF NO
		// REVERSADO
		listaDuplaMovsGMFNoReversado = new ArrayList<MovimientoStratus>();
		for (MovimientoStratus movimiento : totalMovs) { // QUITA LAS CONTRAPARTIDAS
			this.adicionarMovimientoTx(movsRet, movimiento, true); // true = EXCLUIR CONTRAPARTIDAS
		}
		return movsRet;
	}

//***********************************************************************************************************************
	/**
	 * Retorna Object[]:<br>
	 * 0- String[] La información de los datos solicitados<br>
	 * 1- La lista de movimientos [MovimientoStratus] NO cancelados, que
	 * correspondan a una transacción (es decir sólo NOTA_CREDITO o NOTA_DEBITO)
	 * existentes desde una [fechaHoraTx] hasta los [minutosAdd] minutos después,
	 * <b>NO incluye movimientos que cuenten con contrapartida</b>, ya que al tener
	 * contrapartida es como si NO se hubiera hecho. Si no hay movimientos el
	 * retorno es una lista vacía.
	 * 
	 * @param tipoProducto - Tipo del producto, puede ser AH / CC / TARJETA_CREDITO
	 * @param numProducto  - Número del producto
	 * @param arrayVents   - Arreglo con los "VENT" a tener en cuenta para la
	 *                     consulta. En este arreglo NO debe incluirse el VENT
	 *                     inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaHoraTx  - Date que contiene la fecha y hora de consulta inicial.
	 * @param minutosAdd   - Número de minutos a adicionar a la hora inicial.
	 * @param datosTitular - Tipo de documento y número de documento del titular del
	 *                     producto al que se le consultan los movimientos, estos
	 *                     datos son requeridos cuando el producto NO es cuenta de
	 *                     ahorros ni corriente, porque la búsqueda se hace por
	 *                     consulta por [PT_CONSULTA_PORTAF_NIT].
	 */
	public Object[] getDatosYMovimientosEnRango(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaHoraTx, int minutosAdd, String[] datosTitular, String... datosCta) throws Exception {

		this.tipoCtaReal = null; // SE INICIALIZA
		this.numProdCompleto = null; // SE INICIALIZA
		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// ALISTA EL ARREGLO DE FECHA Y HORAS A BUSCAR
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiHoraMov(fechaHoraTx, minutosAdd);
		// 0-DATOS DE LA CUENTA, 1-LISTA DE MOVIMIENTOS
		Object[] arrDatosMovs = this.getDatosYMovimientos(tipoCuenta, numProducto, arrayVents, fechaHoraTx,
				arrFechaHora, true, false, datosCta, datosTitular); // true=excluirCancelados, false=incluirSaldos
		@SuppressWarnings("unchecked")
		List<MovimientoStratus> totalMovs = ((List<MovimientoStratus>) arrDatosMovs[1]);
		List<MovimientoStratus> movsRet = new ArrayList<MovimientoStratus>();
		// INICIALIZA LA LISTA DE DUPLAS DE MOVIMIENTOS CONTRAPARTIDA CON GMF NO
		// REVERSADO
		listaDuplaMovsGMFNoReversado = new ArrayList<MovimientoStratus>();
		if (totalMovs != null) {
			for (MovimientoStratus movimiento : totalMovs) { // QUITA LAS CONTRAPARTIDAS
				this.adicionarMovimientoTx(movsRet, movimiento, true); // true = EXCLUIR CONTRAPARTIDAS
			}
		}
		arrDatosMovs[1] = movsRet;
		return arrDatosMovs;
	}

//***********************************************************************************************************************
	/**
	 * Retorna Object[]:<br>
	 * 0- String[] La información de los datos solicitados<br>
	 * 1- La lista de movimientos [MovimientoStratus] NO cancelados, que
	 * correspondan a una transacción (es decir sólo NOTA_CREDITO o NOTA_DEBITO)
	 * existentes desde una [fechaHoraTx] hasta los [minutosAdd] minutos después,
	 * <b>SÍ incluye movimientos que cuentan con contrapartida</b>. Si no hay
	 * movimientos el retorno es una lista vacía.
	 * 
	 * @param tipoProducto - Tipo del producto, puede ser AH / CC / TARJETA_CREDITO
	 * @param numProducto  - Número del producto
	 * @param arrayVents   - Arreglo con los "VENT" a tener en cuenta para la
	 *                     consulta. En este arreglo NO debe incluirse el VENT
	 *                     inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaHoraTx  - Date que contiene la fecha y hora de consulta inicial.
	 * @param minutosAdd   - Número de minutos a adicionar a la hora inicial.
	 * @param datosTitular - Tipo de documento y número de documento del titular del
	 *                     producto al que se le consultan los movimientos, estos
	 *                     datos son requeridos cuando el producto NO es cuenta de
	 *                     ahorros ni corriente, porque la búsqueda se hace por
	 *                     consulta por [PT_CONSULTA_PORTAF_NIT].
	 */
	public Object[] getDatosYAllMovimientosEnRango(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaHoraTx, int minutosAdd, String[] datosTitular, String... datosCta) throws Exception {

		this.tipoCtaReal = null; // SE INICIALIZA
		this.numProdCompleto = null; // SE INICIALIZA
		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// ALISTA EL ARREGLO DE FECHA Y HORAS A BUSCAR
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiHoraMov(fechaHoraTx, minutosAdd);
		// 0-DATOS DE LA CUENTA, 1-LISTA DE MOVIMIENTOS
		Object[] arrDatosMovs = this.getDatosYMovimientos(tipoCuenta, numProducto, arrayVents, fechaHoraTx,
				arrFechaHora, true, false, datosCta, datosTitular); // true=excluirCancelados, false=incluirSaldos
		@SuppressWarnings("unchecked")
		List<MovimientoStratus> totalMovs = ((List<MovimientoStratus>) arrDatosMovs[1]);
		List<MovimientoStratus> movsRet = new ArrayList<MovimientoStratus>();
		// INICIALIZA LA LISTA DE DUPLAS DE MOVIMIENTOS CONTRAPARTIDA CON GMF NO
		// REVERSADO (PARA DEJARLA EN VACÍO)
		listaDuplaMovsGMFNoReversado = new ArrayList<MovimientoStratus>();
		if (totalMovs != null) {
			for (MovimientoStratus movimiento : totalMovs) {
				this.adicionarMovimientoTx(movsRet, movimiento, false); // false = INCLUIR CONTRAPARTIDAS
			}
		}
		arrDatosMovs[1] = movsRet;
		return arrDatosMovs;
	}

//***********************************************************************************************************************
	/**
	 * Retorna la lista de movimientos [MovimientoStratus] NO cancelados existentes
	 * en un rango de fechas dada, desde [fechaInicial] hasta [fechaFinal], NO tiene
	 * en cuenta las horas.
	 * 
	 * @param tipoProducto - Puede ser Ahorro / Corriente / Tarjeta de Crédito, con
	 *                     este dato se busca el tipo de cuenta que puede ser
	 *                     ingresado en la consulta.
	 * @param numProducto  - Número del producto
	 * @param arrayVents   - Arreglo con los "VENT" a tener en cuenta para la
	 *                     consulta. En este arreglo NO debe incluirse el VENT
	 *                     inicial que es [MovimientoStratus.VENT_INDIC]
	 * @param fechaInicial - Date que contiene la fecha de consulta inicial.
	 * @param fechaFinal   - Date que contiene la fecha de consulta final.
	 * @param datosTitular - Tipo de documento y número de documento del titular del
	 *                     producto al que se le consultan los movimientos, estos
	 *                     datos son requeridos cuando el producto NO es cuenta de
	 *                     ahorros ni corriente, porque la búsqueda se hace por
	 *                     consulta por [PT_CONSULTA_PORTAF_NIT].
	 * @return Lista con todos los movimientos
	 */
	public List<MovimientoStratus> getMovimientosEnRango(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaInicial, Date fechaFinal, String... datosTitular) throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		String[] arrFechaHora = StratusProductos.getArrayAll_FsiMov(fechaInicial, fechaFinal); // ARRAY FECHAS A BUSCAR
		return this.getMovimientos(tipoCuenta, numProducto, arrayVents, fechaInicial, arrFechaHora, true, datosTitular);
	}

//***********************************************************************************************************************
	/**
	 * Retorna los datos y los movimientos de una cuenta de ahorros o corriente.<br>
	 * Los datos retornados serán los indicados por [datos].<br>
	 * Los movimientos serán los comprendidos entre [fechaInicial] y [fechaFinal].
	 * 
	 * @param tipoCuenta        - Puede ser Ahorro / Corriente.
	 * @param numCuenta         - Número de la cuenta.
	 * @param arrayVents        - Arreglo con los "VENT" a tener en cuenta para la
	 *                          consulta. En este arreglo NO debe incluirse el VENT
	 *                          inicial que es [MovimientoStratus.VENT_INDIC], puede
	 *                          venir en [null] y en tal caso tomará sólo el
	 *                          inicial.
	 * @param fechaInicial      - Date que contiene la fecha de consulta inicial.
	 * @param fechaFinal        - Date que contiene la fecha de consulta final.
	 * @param excluirCancelados - Excluye los movimientos con IND en "C" que
	 *                          corresponden a los cancelados.
	 * @param incluirSaldos     - Indica si se va a hacer consulta de saldos, en tal
	 *                          caso retorna en las primeras posiciones del array de
	 *                          String del retorno en l aposiicón 0 : 0-Saldo
	 *                          Disponible, el 1-Saldo Total, 2-#CtaCentralizadora.
	 * @param datos             - Datos a extraer de la cuenta. Cada dato recibido
	 *                          debe corresponder al <b>label del dato</b> como se
	 *                          muestra en Stratus en la pantalla "C O N S U L T A D
	 *                          E M A E S T R A S".
	 * @return - Arreglo de dos elementos:<br>
	 *         0 - String[] con los valores de los datos consultados de la cuenta.
	 *         [null] si no hubo consulta de datos. En caso contrario:<br>
	 *         + Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         + Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         + Si la consulta NO retorna ERROR por ninguna consulta, retorna:<br>
	 *         incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora (si tiene), 3-..Datos<br>
	 *         incluirSaldos = false >> 0-..Datos<br>
	 *         1 - List<MovimientoStratus> los movimientos encontrados. [null] si
	 *         hubo error con la cuenta.
	 */
	public Object[] getDatosYMovimientosCta(String tipoCuenta, String numCuenta, String[] arrayVents, Date fechaInicial,
			Date fechaFinal, boolean excluirCancelados, boolean incluirSaldos, String... datos) throws Exception {

		String tipoCta = StratusProductos.getTipoCuenta(tipoCuenta); // GARANTIZA EL DATO
		String[] arrFecha = StratusProductos.getArrayAll_FsiMov(fechaInicial, fechaFinal); // ARRAY FECHAS A BUSCAR
		return this.getDatosYMovimientos(tipoCta, numCuenta, arrayVents, fechaInicial, arrFecha, excluirCancelados,
				incluirSaldos, datos, null);
	}

//=======================================================================================================================
	// TODO >> MÉTODOS QUE REQUIEREN QUE YA SE ESTÉ LOGUEADO EN STRATUS:
	/**
	 * Se recibe el tipo de la cuenta (AH o CC) y el número de la cuenta. Se espera
	 * estar en la pantalla [PT_CONSULTA_MAESTRAS] si no está determina en qué
	 * pantalla puede estar, para volver a ingresar.<br>
	 * Deja la pantalla de Stratus en la consulta de la cuenta con los datos de la
	 * misma.<br>
	 * Retorna el contenido de la pantalla si se pudo hacer consulta de los datos,
	 * en caso que la consulta muestre alguno de los mensajes existentes en
	 * [MSGS_CTA_SINDATOS] el retorno será dicho mensaje.<br>
	 * La pantalla en Stratus queda en [PT_CONSULTA_MAESTRAS]<br>
	 * Si se pudo hacer la consulta, en [this.numProdCompleto] queda el dato del
	 * número de la cuenta con prefijo "05"
	 */
	private String ingresarDatosCta(String tipoCta, String numeroCta, boolean guardarEvidencia) throws Exception {

		String numCta = getNumCtaParaConsultaMaestra(numeroCta);
		boolean esMigrada = esCuentaMigrada(numCta);
		this.numProdCompleto = numCta;
//-----------------------------------------------------------------------------------------------------------------------
		String pantalla = this.read();
		// SI NO ESTÁ EN LA PANTALLA DE [CONSULTA DE MAESTRAS], SE DIRIGE A ESA PANTALLA
		if (!pantalla.contains(PT_CONSULTA_MAESTRAS)) {
			if (!pantalla.contains(CommonStratus.PT_INICIO)) // SI NO ESTÁ EN EL INICIO, VA AL INICIO 1RO
				this.returnInicio();
			this.irConsultaMaestra();
		}
		// INGRESA LA INFORMACIÓN PARA REALIZAR LA CONSULTA:
		this.ctrlX(2); // GARANTIZA QUE EL CURSOR QUEDE EN EL CAMPO "TIPO CTA" Y EL BORRADO DE LA
						// CONSULTA ANTERIOR
		this.sendKey(tipoCta.charAt(0)); // INGRESA LA PRIMERA LETRA DEL TIPO DE CUENTA
		this.tab(1);
		this.paste(numCta); // PEGA EL NÚMERO DE LA CUENTA, COMO SE GARANTIZA EL TAMAÑO DEL DATO HACE LA
							// CONSULTA
		String textoPantalla, numCtaStr, textoFin;
		int posMsgError = -1;
		do { // CICLO PARA GARANTIZAR QUE LA PANTALLA CONTIENE LA INFORMACIÓN DE LA CUENTA
			textoPantalla = this.read();
			numCtaStr = Util.getTextoEntre(textoPantalla, "DATOS PERSONALES DEL PRODUCTO :", "NIT");
			textoFin = this.getLineaError(textoPantalla, true);
			posMsgError = Util.posItemContainsAnyArrayItem(textoFin, MSGS_CTA_SINDATOS);
		} while (numCtaStr.isEmpty() && posMsgError == -1);
//-----------------------------------------------------------------------------------------------------------------------
		this.tipoCtaReal = Util.getTextoEntre(textoPantalla, " TIPO CTA", "CTA/TAR");
		tipoCta = this.tipoCtaReal; // PARA GARANTIZAR QUE TOME LA REAL (EN LAS EVIDENCIAS)
		if (guardarEvidencia)
			this.saveEvidence("DatosCta-" + tipoCta + numCta);
		if (posMsgError != -1) {
			textoPantalla = MSGS_CTA_SINDATOS[posMsgError];
			// SI NO REQUERÍA GUARDAR LA EVIDENCIA, PERO HUBO ERROR, SE DEBE GUARDAR
			if (!guardarEvidencia)
				this.saveEvidence("DatosCta-" + tipoCta + numCta);
		} else { // NO HAY ERROR, ALMACENA EN [this.numProdCompleto] EL DATO DE LA CUENTA CON
					// PREFIJO "05"
			this.numProdCompleto = numCta;
			if (Util.left(numCta, 2).equals("00")) // NO TIENE PREFIJO
				this.numProdCompleto = numCtaStr;
			if (esMigrada) { // MIRA SI ALMACENA LA CUENTA MIGRADA AL MAP [dicCtasAsoc_Migradas]
				String keyDic = tipoCta + "-" + numCta;
				if (!dicCtasAsoc_Migradas.containsKey(keyDic))
					dicCtasAsoc_Migradas.put(keyDic, this.numProdCompleto);
			}
		}
		return textoPantalla;
	}

//***********************************************************************************************************************
	/**
	 * Método que hace la consulta de los productos del cliente con identificación
	 * [numeroDoc] y [tipoDoc]. Y busca entre el listado de productos aquel que
	 * corresponda al [tipoProducto] y [numProducto], dejando el cursor de Stratus
	 * en la posición del producto.<br>
	 * Puede dejar la pantalla en la consulta de datos, en las cuentas migradas,
	 * porque entra a corroborar que el tipo de producto buscado corresponda, se
	 * reconoce porque el retorno en la posición 1 NO está vacío.<br>
	 * La variable [this.numProdCompleto] se llena con el número completo del
	 * producto sobre el que se deja el cursor.<br>
	 * <b>Pre-requisito:</b> Se espera estar en la pantalla
	 * [PT_CONSULTA_PORTAF_NIT].<br>
	 * 
	 * @return String[] de 2 posiciones:<br>
	 *         - Pos 0 : Cadena vacía si se encuentra el producto, en caso contrario
	 *         retorna el error presentado.<br>
	 *         - Pos 1 : Cadena vacía si no se ingresó a los datos del producto, si
	 *         se encontró y se ingresó retorna el contenido de la pantalla de
	 *         Stratus.
	 */
	private String[] ubicarCursorEnProducto(String tipoDoc, String numeroDoc, String tipoProducto, String numProducto,
			boolean guardarEvidencia) throws Exception {

		return ubicarCursorEnProducto(tipoDoc, numeroDoc, tipoProducto, numProducto, guardarEvidencia, true);
	}

//***********************************************************************************************************************
	/**
	 * Método que hace la consulta de los productos del cliente con identificación
	 * [numeroDoc] y [tipoDoc], desde que [es1rstConsulta] esté en [true] de lo
	 * contrario se asume que ya está en la pantalla con productos.<br>
	 * Busca entre el listado de productos aquel que corresponda al [tipoProducto] y
	 * [numProducto], dejando el cursor de Stratus en la posición del producto.<br>
	 * Puede dejar la pantalla en la consulta de datos, en las cuentas migradas,
	 * porque entra a corroborar que el tipo de producto buscado corresponda, se
	 * reconoce porque el retorno en la posición 1 NO está vacío.<br>
	 * La variable [this.numProdCompleto] se llena con el número completo del
	 * producto sobre el que se deja el cursor.<br>
	 * <b>Pre-requisito:</b> Se espera estar en la pantalla [PT_CONSULTA_PORTAF_NIT]
	 * y que el cursor se encuentre ubicado en el primer elemento.<br>
	 * 
	 * @param es1rstConsulta - Si es true hace consulta ingresando los datos del
	 *                       titular, en caso contrario, se asume que ya está en la
	 *                       pantalla con los productos
	 * @return String[] de 2 posiciones:<br>
	 *         - Pos 0 : Cadena vacía si se encuentra el producto, en caso contrario
	 *         retorna el error presentado.<br>
	 *         - Pos 1 : Cadena vacía si no se ingresó a los datos del producto, si
	 *         se encontró y se ingresó retorna el contenido de la pantalla de
	 *         Stratus.
	 */
	private String[] ubicarCursorEnProducto(String tipoDoc, String numeroDoc, String tipoProducto, String numProducto,
			boolean guardarEvidencia, boolean es1rstConsulta) throws Exception {

//-----------------------------------------------------------------------------------------------------------------------
		// ALISTA LA INFORMACIÓN DEL DATO CON EL QUE SE COMPARA:
		String numProd = numProducto.trim();
		String[] tiposProd4Dig = { CTA_AHORROS, CTA_CORRIENTE, CREDITO, TARJETA_CREDITO };
		// SI TIENE EL TAMAÑO COMPLETO Y NO TIENE * LA BÚSQUEDA SE HACE POR EL NÚMERO
		// COMPLETO QUE SE RECIBIÓ
		if (Util.trimLeft(numProd, '0').length() < TAM_NUM_CTA - 1 || numProd.contains("*")) {
			if (Util.itemInArray(tipoProducto, tiposProd4Dig))
				numProd = Util.right(numProducto, 4); // Toma los últimos 4 dígitos
			else // if (numProd.length() != TAM_NUM_CTA) // Hace la búsqueda del producto por
					// todo el número recibido
				numProd = Util.leftComplete(numProd, TAM_NUM_CTA, '0');
		}
//-----------------------------------------------------------------------------------------------------------------------
		// ALISTA LA INFORMACIÓN DEL DATO QUE SE BUSCA POR PÁGINA Y POR LÍNEA:
		String numBuscar = numProd + " "; // Concatena espacio al final (busca coincidencia con los últimos dígitos)
		if (tipoProducto.equals(CREDITO_COBROS_PORTAF)) {
			numProd = Util.left(numProd, 15); // Los primeros 15 dígitos
			numBuscar = " " + numProd; // Se concatena espacio al inicio (busca coincidencia con los primeros dígitos)
		}
//-----------------------------------------------------------------------------------------------------------------------
		// INGRESA LOS DATOS DE CONSULTA, SÓLO SI [es1rstConsulta], EN CASO CONTRARIO
		// HACE LECTURA DE LA PANTALLA
		String[] arrayLinea = null;
		String textoPantalla;
		if (es1rstConsulta) {
			arrayLinea = this.ingresarDatosConsPortafolio(tipoDoc, numeroDoc, guardarEvidencia);
			if (arrayLinea.length == 1)
				return new String[] { arrayLinea[0], "" }; // HAY ERROR
			textoPantalla = arrayLinea[0];
		} else {
			textoPantalla = this.read();
			arrayLinea = textoPantalla.split("\n"); // Enter
		}
//-----------------------------------------------------------------------------------------------------------------------
		boolean esTempActual = CommonStratus.evidenceTemporal;
		CommonStratus.evidenceTemporal = true;
//-----------------------------------------------------------------------------------------------------------------------
		// ENCONTRÓ PRODUCTOS, SE EMPIEZA A BUSCAR EL PRODUCTO REQUERIDO
		String[] cuentas;
		String linea, msgErrorTemp = "", msgError = "", pantallaDatosCta = "";
		int numDown = 0, numTab = 0;
		boolean muestraCtas, estaEnLinea, esCta, encontroCta = false;
		int numOcurrPantalla = 0;
		do {
			muestraCtas = !Util.limpiarTexto(arrayLinea[RENG_INICIO_PRODS], '|').isEmpty();
			if (!muestraCtas) { // YA NO HAY MÁS CUENTAS PARA VISUALIZAR
				pantallaDatosCta = "";
				msgError = "NO SE ENCUENTRA EL PRODUCTO [" + tipoProducto + " - " + numProducto + "]";
				break; // TERMINA EL CICLO
			}
			numDown = 0;
			// SE PUEDE SEGUIR BUSCANDO EL PRODUCTO: VALIDA SI EL PRODUCTO SE ENCUENTRA EN
			// LA PÁGINA
			encontroCta = textoPantalla.contains(numBuscar);
			if (encontroCta) { // ENCONTRÓ EL PRODUCTO EN LA PÁGINA PARA FONDOS PREGUNTA EL NÚMERO DE
								// OCURRENCIAS,
				// PUEDE PASAR QUE HAYAN CUENTAS CON EL MISMO # DEL FONDO
				if (tipoProducto.equals(FONDO_INVERSION))
					numOcurrPantalla = Util.getNumOcurrencias(textoPantalla, numBuscar);
				for (int posLinea = RENG_INICIO_PRODS; posLinea <= RENG_FIN_PRODS; posLinea += 2) { // VA DE 2 EN 2
					linea = arrayLinea[posLinea];
					estaEnLinea = linea.contains(numBuscar);
					if (!estaEnLinea)
						numDown++;
					else { // ENCONTRÓ EL PRODUCTO EN LA LÍNEA
						numTab = 0;
						cuentas = Util.limpiarTexto(linea, '|').split(" ");
						for (int posCta = 0; posCta < cuentas.length; posCta++) {
							esCta = StratusProductos.isProductoBuscado(tipoProducto, numProd, cuentas[posCta]);
							encontroCta = false; // PARA QUE SIGA BUSCANDO
							if (!esCta)
								numTab++;
							else { // CREE QUE ENCONTRÓ EL NÚMERO DEL PRODUCTO
								encontroCta = true;
								this.numProdCompleto = cuentas[posCta];
								if (((tipoProducto.equals(CTA_CORRIENTE) || tipoProducto.equals(CTA_AHORROS))
										&& StratusProductos.esCuentaMigrada(this.numProdCompleto))
										|| (tipoProducto.equals(FONDO_INVERSION) && numOcurrPantalla > 1)) {
									pantallaDatosCta = this.productoCorrespondeConTipo(numDown, numTab, tipoProducto);
									if (pantallaDatosCta.isEmpty()) { // NO ERA EL PRODUCTO
										numTab++; // PARA QUE PASE AL SIGUIENTE NÚMERO DE CUENTA
										encontroCta = false;
									} else {
										posCta = cuentas.length; // PARA TERMINAR EL CICLO QUE RECORRE CUENTA A CUENTA
										posLinea = RENG_FIN_PRODS + 1; // PARA TERMINAR EL CICLO QUE RECORRE LAS LÍNEAS
										if (tipoProducto.equals(FONDO_INVERSION))
											pantallaDatosCta = ""; // NO HAY PANTALLA DE DATOS PARA UN FONDO
									}
								} // IF : ES CC o AH Y ES MIGRADA / ES FONDO Y EN LA PANTALLA HAY VARIAS
									// OCURRENCIAS DEL NÚMERO DEL PRODUCTO
								else {
									posCta = cuentas.length; // PARA TERMINAR EL CICLO QUE RECORRE CUENTA A CUENTA
									posLinea = RENG_FIN_PRODS + 1; // PARA TERMINAR EL CICLO QUE RECORRE LAS LÍNEAS
									if (tipoProducto.equals(FONDO_INVERSION))
										pantallaDatosCta = ""; // NO HAY PANTALLA DE DATOS PARA UN FONDO
								}
							} // ELSE : CREE QUE ENCONTRÓ EL PRODUCTO
						} // FOR : CICLO QUE RECORRE CUENTA A CUENTA
						if (!encontroCta)
							msgErrorTemp = "PARA EL PRODUCTO [" + tipoProducto + " - " + numProducto + "] SE ENCONTRÓ "
									+ "UNO POSIBLE PERO NO CUMPLIÓ CON LAS REGLAS - REVISAR SI SON CORRECTAS "
									+ "[StratusProductos.isProductoBuscado]";
					} // ELSE : ENCONTRÓ EL PRODUCTO EN LA LÍNEA
				} // FOR : CICLO QUE RECORRE LAS LÍNEAS
			} // IF : ENCONTRÓ EL PRODUCTO EN LA PÁGINA
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// EL SIGUIENTE SE PONE COMO IF Y NO COMO ELSE, PORQUE AVECES PUEDE QUE SE VEA
				// EL PRODUCTO EN LA HOJA O
				// EN LAS LÍNEAS PERO AL EVALUAR SI ES EL PRODUCTO BUSCADO, PUEDE QUE NO SEA POR
				// ALGUNA DE LAS REGLAS
			if (!encontroCta) {
				this.ctrlX(6); // F6 - AV PAG
				if (guardarEvidencia)
					this.saveEvidence("ConsultaPortafolioNit-Next");
				textoPantalla = this.read();
				arrayLinea = textoPantalla.split("\n"); // Enter
			}
		} while (!encontroCta);
//-----------------------------------------------------------------------------------------------------------------------
		// MANTIENE LA EVIDENCIA TEMPORAL, SI NO ENCUENTRA EL PRODUCTO
		Evidence.cleanTempEvidence(!encontroCta);
		CommonStratus.evidenceTemporal = esTempActual; // CON EL VALOR QUE TENÍA
//-----------------------------------------------------------------------------------------------------------------------
		if (pantallaDatosCta.isEmpty() && encontroCta) { // HACE EL MOVIMIENTO DEL CURSOR PORQUE NO ESTÁ EN LOS DATOS
			this.down(numDown); // FLECHA HACIA ABAJO
			this.tab(numTab); // HACE LOS TABs INDICADOS POR [numTab]
			if (guardarEvidencia)
				this.saveEvidence("ProdEncontrado");
		}
		if (!encontroCta && !msgErrorTemp.isEmpty())
			msgError = msgErrorTemp;
		return new String[] { msgError, pantallaDatosCta };
	}

//***********************************************************************************************************************
	/**
	 * Este método se usa cuando se está consultando una cuenta de ahorro o
	 * corriente desde [PT_CONSULTA_PORTAF_NIT] y su número de cuenta empieza con
	 * mínimo 6 ceros (es migrada) en tal caso no se puede identificar si es AH o
	 * CC, por eso se debe ingresar a ver sus datos y que el tipo de cuenta de la
	 * consulta corresponda al [tipoCta].<br>
	 * También se usa para FONDOS cuyo número tmbién se está presentando en otros
	 * productos.<br>
	 * La pantalla se encuentra en [PT_CONSULTA_PORTAF_NIT] y el cursor está ubicado
	 * en la primera cuenta de la pantalla.<br>
	 * OJO: Para AH o CC y los datos corresponden Stratus queda en la pantalla de
	 * CONSULTAS MAESTRAS, si no corresponde retorna a la pantalla
	 * [PT_CONSULTA_PORTAF_NIT] y deja el cursor ubicado en la primera cuenta como
	 * estaba.<b> Parsa FONDOS si el producto corresponde, de todas formas retorna a
	 * la [PT_CONSULTA_PORTAF_NIT].
	 * 
	 * @param numDown - Número de flechas hacia abajo a ingresar.
	 * @param numTab  - Número de tabs a ingresar
	 * @param tipoCta - Tipo de cuenta buscado.
	 * @return El contendio de la pantalla Stratus si la cuenta consultada
	 *         corresponde al [tipoCta]<br>
	 *         Si la cuenta no corresponde el retorno es un String VACIO.
	 * @throws Exception
	 */
	private String productoCorrespondeConTipo(int numDown, int numTab, String tipoCta) throws Exception {

		this.down(numDown); // FLECHA HACIA ABAJO
		this.tab(numTab); // HACE LOS TABs INDICADOS POR [numTab]
		String fileTemp = this.saveEvidence("ProdEncontrado");
		boolean esFondo = tipoCta.equals(FONDO_INVERSION);
		int opcion = 2; // F2 - DATOS
		if (esFondo)
			opcion = 1; // F1 - SALDO
		this.ctrlX(opcion); // SALDO o DATOS
		String pantalla;
		do { // HACE CICLO MIENTRAS NO MUESTRE LA PANTALLA [PT_CONSULTA_MAESTRAS] NI
				// [PT_CONSULTA_SALDO_FOND]
			pantalla = this.read();
		} while (!pantalla.contains(PT_CONSULTA_MAESTRAS) && !pantalla.contains(PT_CONSULTA_SALDO_FOND));
		boolean productoCorresponde = false;
		if (esFondo)
			productoCorresponde = pantalla.contains(PT_CONSULTA_SALDO_FOND);
		else if (pantalla.contains(PT_CONSULTA_MAESTRAS)) {
			String tipoCtaStr = Util.getTextoEntre(pantalla, "TIPO CTA", "CTA/TAR");
			productoCorresponde = tipoCtaStr.equals(tipoCta);
		}
		if (!productoCorresponde || (productoCorresponde && esFondo)) {
			if (!productoCorresponde)
				pantalla = "";
			// RETORNA A LA PANTALLA [PT_CONSULTA_PORTAF_NIT] Y DEJA EL CURSOR EN LA PRIMERA
			// CUENTA: 1down, 2tabs, 1up
			this.escapeQ(1);
			this.down(1);
			this.tab(2);
			this.up(1);
			// BORRA LA EVIDENCIA TEMPORAL QUE SE CREÓ
			new File(fileTemp).delete();
		}
		return pantalla;
	}

//***********************************************************************************************************************
	/**
	 * Se recibe el tipo de documento y el número del documento. Se espera estar en
	 * la pantalla [PT_CONSULTA_PORTAF_NIT] si no está determina en qué pantalla
	 * puede estar, para volver a ingresar.<br>
	 * Deja la pantalla de Stratus en la consulta de los productos del usuario.<br>
	 * 
	 * @return String[] - 1 sólo elemento si hubo error.<br>
	 *         - De lo contrario retorna las líneas de la pantalla de Stratus.
	 *         <b>OJO</b> en la posición 0 va el texto total de la pantalla de
	 *         Stratus, se hace así ya que por lo general esa parte no se usa.
	 */
	private String[] ingresarDatosConsPortafolio(String tipoDocumento, String numeroDocumento, boolean guardarEvidencia)
			throws Exception {

		// OBTIENE EL TIPO DE DOCUMENTO REQUERIDO POR STRATUS PARA LA CONSULTA
		String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(tipoDocumento);
		String pantalla = this.read();
		// SI NO ESTÁ EN LA PANTALLA DE [PT_CONSULTA_PORTAF_NIT], SE DIRIGE A ESA
		// PANTALLA
		if (!pantalla.contains(PT_CONSULTA_PORTAF_NIT)) {
			if (pantalla.contains(PT_BANCA_EMPRESARIAL))
				this.selectOpcionMenuLista(0); // LA OPCIÓN 0 ES DE SALIR E IR AL MENÚ INICIAL
			this.irConsultaPortafolio();
		}
		// INGRESA LA INFORMACIÓN PARA REALIZAR LA CONSULTA:
		this.borrarValCampo(); // BORRA EL CONTENIDO DEL CAMPO NIT
		this.paste(numeroDocumento);
		this.tab(1);
		this.seleccionarDato(tipoDoc, "Tipo Doc:", "|", StratusBase.MODE_LETTER);
		this.enter(); // DEJA EL CURSOR EN EL NÚMERO DE LA PRIMERA CUENTA SI EXISTE
		String textoPantalla, msgError = "";
		String[] arrayLinea;
		boolean muestraCtas;
		do {
			textoPantalla = this.read();
			arrayLinea = textoPantalla.split("\n"); // Enter
			muestraCtas = !Util.limpiarTexto(arrayLinea[RENG_INICIO_PRODS], '|').isEmpty();
			// AL CONSULTAR LA RELACIÓN NÚMERO DE DOCUMENTO Y TIPO DE DOCUMENTO LA LÍNEA
			// [CommonStratus.RENG_ERROR_GEN]
			// ESTÁN VACÍOS LOS 60 PRIMEROS CARACTERES, SI HAY ERROR: SE LLENA CON
			// INFORMACIÓN
			if (!muestraCtas)
				msgError = Util.totalTrim(Util.left(arrayLinea[CommonStratus.RENG_ERROR_GEN], 60));
		} while (!muestraCtas && msgError.isEmpty());
		if (guardarEvidencia)
			this.saveEvidence("ConsultaPortafolioNit");
		if (muestraCtas) {
			arrayLinea[0] = textoPantalla; // POR LO GENERAL LA POSICIÓN 0 NO SE USA
			return arrayLinea;
		} else
			return new String[] { msgError };
	}

//***********************************************************************************************************************
	/**
	 * Se asume que Stratus cumple con una de estas 2 condiciones:<br>
	 * 1- Se encuentra en la pantalla [PT_CONSULTA_MAESTRAS] y ya se hizo la
	 * consulta de la cuenta.<br>
	 * 2- Se encuentra en la pantalla [PT_CONSULTA_PORTAF_NIT] y el cursor se
	 * encuentra sobre la cuenta.<br>
	 * Se hace la consulta del saldo y deja la pantalla nuevamente en la pantalla
	 * origen de la consulta: [PT_CONSULTA_MAESTRAS] o [PT_CONSULTA_PORTAF_NIT].
	 * 
	 * @param tipoProd         - Tipo del producto.
	 * @param desdeConsMaestra - Indica si la consulta se está haciendo desde
	 *                         [PT_CONSULTA_MAESTRAS]
	 */
	private String getPantallaSaldoCta(String tipoProd, String numProd, boolean desdeConsMaestra) throws Exception {

		String titleEsperado = PT_CONSULTA_SALDO_AH;
		int numEscQ = 1; // NÚMERO DE ESCAPE QUE DEBE DAR PARA RETORNAR A LA PANTALLA ORIGEN DE LA
							// CONSULTA
		this.ctrlX(1);
		// SI EL PRODUCTO ES [CTA_CORRIENTE] DEBE INGRESAR 1 Y CTRL+X1, PARA LOS OTROS
		// PRODUCTOS YA ESTÁ EN EL SALDO
		if (tipoProd.equals(CTA_CORRIENTE)) {
			this.read("MANEJO DE CUENTA CORRIENTE / CREDIPLUS");
			this.sendKey(1);
			this.ctrlX(1);
			titleEsperado = PT_CONSULTA_SALDO_CC;
			numEscQ = 2;
		} else if (tipoProd.equals(CREDITO))
			titleEsperado = PT_CONSULTA_SALDO_CRED;
		else if (tipoProd.equals(TARJETA_CREDITO))
			titleEsperado = PT_CONSULTA_SALDO_TC;
		else if (tipoProd.equals(FONDO_INVERSION))
			titleEsperado = PT_CONSULTA_SALDO_FOND;
		String[] titlesSiSeSale = { PT_CONSULTA_PORTAF_NIT, PT_BANCA_EMPRESARIAL, CommonStratus.PT_INICIO };
		String origen = PT_CONSULTA_MAESTRAS;
		if (!desdeConsMaestra) {
			titlesSiSeSale = new String[] { PT_BANCA_EMPRESARIAL, CommonStratus.PT_INICIO };
			origen = PT_CONSULTA_PORTAF_NIT;
		}
//-----------------------------------------------------------------------------------------------------------------------
		String textoPantalla, lineaError;
		boolean errYAunEnOrigen = false;
		int SEGS_MAX_ESPERA = 5; // MAXIMO ESPERARÁ 5 SEGUNDOS A QUE TRANSICIONE DE PANTALLA, SI NO LO HACE, ES
									// ERROR
		int timeEsp = 0;
		do { // ESPERA MIENTRAS NO SE MUESTRE ALGUNA DE LAS PANTALLAS DE CONSULTA DE SALDO
			Util.wait(1);
			timeEsp++;
			textoPantalla = this.read();
			if (Util.itemContainsAnyArrayItem(textoPantalla, titlesSiSeSale))
				JOptionPane.showMessageDialog(null, "Desde la pantalla [" + origen + "]\n"
						+ "se estaba tratando de consultar el saldo de\n" + "[" + tipoProd + " : " + numProd
						+ "] pero se salió.\n"
						+ "En Stratus ingrese a la pantalla indicada e ingrese al saldo, antes de Aceptar este mensaje.");
			else if (textoPantalla.contains(origen)) {
				lineaError = this.getLineaError(textoPantalla, true); // ERROR GENERAL
				errYAunEnOrigen = Util.itemContainsAnyArrayItem(lineaError, MSGS_CTA_SINDATOS);
			}
		} while (!textoPantalla.contains(titleEsperado) && !errYAunEnOrigen && timeEsp <= SEGS_MAX_ESPERA);
		if (textoPantalla.contains(titleEsperado)) {
			this.saveEvidence("SaldoProducto");
			this.escapeQ(numEscQ); // RETORNA A LA PANTALLA ORIGEN
		} else if (timeEsp > SEGS_MAX_ESPERA) // NO PUDO INGRESAR AL PRODUCTO, NO SALE ERROR NI NADA
			textoPantalla = "DESPUÉS DE UNA ESPERA - NO PERMITIÓ INGRESAR AL SALDO DEL PRODUCTO";
		return textoPantalla;
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un arreglo de String los datos correspondientes a la cuenta cuya
	 * pantalla de "C O N S U L T A D E M A E S T R A S" de Stratus corresponde a
	 * [textoPantalla].<br>
	 * Cada posición del arreglo responde al dato recibido en [datos] y se retorna
	 * el String tal y como se presenta en la pantalla de Stratus pero en
	 * MAYÚSCULAS.<br>
	 * Cada dato recibido debe corresponder al dato como se muestra en Stratus.
	 */
	private String[] getDatosCta(String textoPantalla, String... datos) {

		int totalDatos = (datos == null) ? 0 : datos.length;
		String[] arrRetorno = new String[totalDatos];
		String dato, datoTemp;
		for (int posArr = 0; posArr < totalDatos; posArr++) {
			dato = datos[posArr];
//			if (dato.contains("TIPO CTA"))
//				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "TIPO CTA", "CTA/TAR");
			
			if (dato.contains("TIPO CTA")) {
			    // Buscar la línea que contiene "TIPO CTA"
			    String lineaTipoCta = Util.getLineaQueContiene(textoPantalla, "TIPO CTA");
			    // Buscar el patrón "CTA/TAR" en esa línea
			    String valorCtaTar = "";
			    if (lineaTipoCta != null && lineaTipoCta.contains("CTA/TAR")) {
			        valorCtaTar = lineaTipoCta.replace("TIPO CTA", ""); // quita el label
			        // Reemplaza "CTA/TAR" por salto de línea y CTA/TAR
			        valorCtaTar = valorCtaTar.replace("CTA/TAR", "\nCTA/TAR");
			        // Limpia espacios extras al principio y final
			        valorCtaTar = valorCtaTar.trim();
			    }
			    arrRetorno[posArr] = valorCtaTar;
			}

			else if (dato.contains("DATOS PERSONALES DEL PRODUCTO"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "DATOS PERSONALES DEL PRODUCTO :", "NIT");
			else if (dato.contains("NIT"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "NIT     :", "|");
			else if (dato.contains("OFI RAD"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "OFI RAD", "|");
			else if (dato.contains("VIGENCIA_NUM")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  VIGENCIA :", "|");
				arrRetorno[posArr] = Util.right(Util.left(datoTemp, 20).trim(), 3).trim(); // SON 16 CARACTERES
			} else if (dato.contains("VIGENCIA")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  VIGENCIA :", "|");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("BLOQ TX"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "BLOQ TX:", "|");
			else if (dato.contains("%GMF"))
				arrRetorno[posArr] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "%GMF:", "|"), 4);
			else if (dato.contains("NO SUB"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "NO SUB", "|");
			else if (dato.contains("SUBPROD_NUM")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  SUBPROD  :", "NUMERO    :");
				arrRetorno[posArr] = Util.right(datoTemp, 2).trim(); // ES EL NÚMERO DEL SUBPRODUCTO
			} else if (dato.contains("SUBPROD")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  SUBPROD  :", "NUMERO    :");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("ACTIVIDAD")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  ACTIVIDAD:", "ESTADO    :");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("ESTADO")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "ESTADO    :", "|");
				arrRetorno[posArr] = Util.left(datoTemp, 14).trim(); // SON 14 CARACTERES
			} else if (dato.contains("2DA.CLAVE")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "|  2DA.CLAVE:", "|");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("ACUM EXENTO MES")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "| ACUM EXENTO MES:", "IND.:");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("IND")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "IND.:", "ULT NOV");
				arrRetorno[posArr] = Util.left(datoTemp, 16).trim(); // SON 16 CARACTERES
			} else if (dato.contains("F. APERTURA")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "F. APERTURA:", "OFI RAD");
				arrRetorno[posArr] = Util.left(datoTemp, 10).trim(); // SON 16 CARACTERES
			} else if (dato.contains("TARJ TOK")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "TARJ TOK:", "#");
				arrRetorno[posArr] = Util.left(datoTemp, 6).trim(); // SON 6 CARACTERES
			} else if (dato.contains("INFO BLOQUEO")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "VIGENCIA :", "|");
				datoTemp = Util.right(datoTemp, 24).trim();
				// Convertimos la cadena en un array de palabras
				String[] palabras = datoTemp.split("\\s+"); // Divide por espacios en blanco
				// Unimos el array de palabras en una sola cadena separada por comas
				arrRetorno[posArr] = String.join(", ", palabras);
				datoTemp = Util.getTextoEntre(textoPantalla, "VIGENCIA :", "|");
				// para garantizar que las pos de los datos siempre será la misma
				String movBloqueo = Util.mid(datoTemp, 20, 18).trim().concat(",");// datoTemp.substring(20,
																					// 40).trim().concat(",");
				arrRetorno[posArr] = movBloqueo + String.join(",", palabras);
			} else if (dato.contains("IN.CONG")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "IN.CONG:", "%GMF:");
				arrRetorno[posArr] = Util.left(datoTemp, 3).trim(); // SON 16 CARACTERES
			} else if (dato.contains("TIPO MANEJO")) {
				datoTemp = Util.getTextoEntre(textoPantalla, "TIPO MANEJO :", "|");
				arrRetorno[posArr] = Util.left(datoTemp, 12).trim(); // SON 12 CARACTERES
			} else if (dato.contains("U.MOV")) {
				  // Buscar la línea que contiene "TIPO CTA"
				String dato1 = Util.getLineaQueContiene(textoPantalla, "U.MOV");
				arrRetorno[posArr] = dato1.replace("TARJ TOK:", " ").replace("#"," ").replace("VALOR", " ").replace("|", " ").replace("U.MOV", " ").replace("Medios:", " ").replace(" ", "");
			
			}else if (dato.contains("NOMBRE"))
				arrRetorno[posArr] = Util.getTextoEntre(textoPantalla, "|  NOMBRE   :", "AFINIDAD:");
			else
				arrRetorno[posArr] = "DATO NO CONTEMPLADO EN MÉTODO [Stratus.getDatosCta]";
		}
		return arrRetorno;
	}

//***********************************************************************************************************************
	/**
	 * Hace la consulta de los movimientos correspondientes al [tipoProducto] y
	 * [numProducto] recibidos, lo intenta hacer por CONSULTA MAESTRA si
	 * [tipoProducto] corresponde a [CTA_CORRIENTE] o [CTA_AHORROS] o si no se envió
	 * información de [datosTitular], cuando se reciben los [datosTitular] se llega
	 * a la pantalla de CONSULTA MOVIMIENTO a través de la pantalla
	 * [PT_CONSULTA_PORTAF_NIT].<br>
	 * 
	 * @param tipoProducto      - Tipo del producto, debe ser como se consulta por
	 *                          MAESTRA: AH / CC / DE y si no es nignuno de estos
	 *                          valores, debe ser como se consulta por CONSUTA
	 *                          MOVIMIENTO: AHD / FDH / FMS / ADQ...
	 * @param numProducto       - Número del producto al que se le consultan los
	 *                          movimientos
	 * @param arrayVents        - Ventanas a revisar de los movimientos. En este
	 *                          arreglo NO debe incluirse el VENT inicial que es
	 *                          [MovimientoStratus.VENT_INDIC]
	 * @param fechaConsulta     - Date que contiene la fecha de consulta de los
	 *                          movimientos.
	 * @param arrFechaHora      - Array que contiene las fechas (mmdd) o las fechas
	 *                          y horas (mmdd hhmm ) de los movimientos que se
	 *                          buscan.
	 * @param excluirCancelados - Excluye los movimientos con IND en "C" que
	 *                          corresponden a los cancelados
	 * @param datosTitular      - Si se incluye el dato, se esperan 2: Tipo de
	 *                          documento y número de documento del titular del
	 *                          producto al que se le consultan los movimientos,
	 *                          estos datos son requeridos cuando el producto NO es
	 *                          cuenta de ahorros ni corriente, porque la búsqueda
	 *                          se hace por consulta yendo a
	 *                          [PT_CONSULTA_PORTAF_NIT].
	 * @return - Retorna los movimientos encontrados
	 */
	@SuppressWarnings("unchecked")
	public List<MovimientoStratus> getMovimientos(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaConsulta, String[] arrFechaHora, boolean excluirCancelados, String... datosTitular)
			throws Exception {

		String tipoCuenta = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// 0-DATOS Y SALDOS DE LA CUENTA, 1-LISTA DE MOVIMIENTOS
		Object[] arrDatos = this.getDatosYMovimientos(tipoCuenta, numProducto, arrayVents, fechaConsulta, arrFechaHora,
				excluirCancelados, false, null, datosTitular);
		return ((List<MovimientoStratus>) arrDatos[1]);
	}

//***********************************************************************************************************************
	/**
	 * Hace la consulta de los últimos movimientos de crédito o débito
	 * correspondientes al [tipoProducto] y [numProducto] recibidos, la cantidad de
	 * movimientos retornada es [numMovimientos]. Lo intenta hacer por CONSULTA
	 * MAESTRA si [tipoProducto] corresponde a [CTA_CORRIENTE] o [CTA_AHORROS] o si
	 * no se envió información de [datosTitular], cuando se reciben los
	 * [datosTitular] se llega a la pantalla de CONSULTA MOVIMIENTO a través de la
	 * pantalla [PT_CONSULTA_PORTAF_NIT].<br>
	 * 
	 * @param numMovimientos - Número de movimientos a retornar.
	 * @param tipoProducto   - Tipo del producto, debe ser como se consulta por
	 *                       MAESTRA: AH / CC / DE y si no es nignuno de estos
	 *                       valores, debe ser como se consulta por CONSUTA
	 *                       MOVIMIENTO: AHD / FDH / FMS / ADQ...
	 * @param numProducto    - Número del producto al que se le consultan los
	 *                       movimientos
	 * @param arrayVents     - Ventanas a revisar de los movimientos. En este
	 *                       arreglo NO debe incluirse el VENT inicial que es
	 *                       [MovimientoStratus.VENT_INDIC]
	 * @param datosTitular   - Si se incluye el dato, se esperan 2: Tipo de
	 *                       documento y número de documento del titular del
	 *                       producto al que se le consultan los movimientos, estos
	 *                       datos son requeridos cuando el producto NO es cuenta de
	 *                       ahorros ni corriente, porque la búsqueda se hace por
	 *                       consulta yendo a [PT_CONSULTA_PORTAF_NIT].
	 * @return - Retorna los últimos movimientos créditos y débitos, la lista tiene
	 *         una longitud <= [numMovimientos]
	 */
	public List<MovimientoStratus> getLastMovimientos(int numMovimientos, String tipoProducto, String numProducto,
			String[] arrayVents, String... datosTitular) throws Exception {

		String tipoProd = StratusProductos.getTipoCuenta(tipoProducto); // GARANTIZA EL DATO
		// 0-DATOS Y SALDOS DE LA CUENTA, 1-LISTA DE MOVIMIENTOS
		boolean selectProdConsMov = false; // SELECCIONA EL PRODUCTO EN "C O N S U L T A M O V I M I E N T O"
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
//-----------------------------------------------------------------------------------------------------------------------
		// PARA CUENTA DE AHORROS O CORRIENTE Y QUE NO TRAIGA DATOS DEL TITULAR, HACE LA
		// CONSULTA DEL PRODUCTO EN
		// [PT_CONSULTA_MAESTRAS]
		if ((tipoProd.equals(CTA_CORRIENTE) || tipoProd.equals(CTA_AHORROS))
				&& (datosTitular == null || datosTitular.length == 0 || datosTitular[0] == null)) {
			this.irConsultaMaestra();
			this.ingresarDatosCta(tipoProd, numProducto, false);
		}
//-----------------------------------------------------------------------------------------------------------------------
		else {
			if (datosTitular == null || datosTitular.length == 0 || datosTitular[0] == null) {
				this.irConsultaMaestra(); // DEBE IR A CONSULTA MAESTRAS Y LUEGO ENTRAR DE UNA A LA CONSULTA DE MOVS
				selectProdConsMov = true;
			} else { // SI SE CUENTA CON DATOS DEL TITULAR HACE LA CONSULTA DEL PRODUCTO EN
						// [PT_CONSULTA_PORTAF_NIT]
				String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(datosTitular[0]); // GARANTIZA EL DATO
				String numDoc = datosTitular[1];
				this.irConsultaPortafolio();
				// 0:Error, 1:Pantalla
				String[] arrCursorEnProd = this.ubicarCursorEnProducto(tipoDoc, numDoc, tipoProd, numProducto, true);
				if (!arrCursorEnProd[0].isEmpty()) {
					this.returnInicio();
					return null;
				}
			}
		}
//-----------------------------------------------------------------------------------------------------------------------
		this.ctrlX(4); // F4 - MOVIMIENTOS : PARA CONSULTAR LOS MOVIMIENTOS
		String textoEnPantalla = this.read(PT_CONSULTA_MOVIMIENTO); // ESPERA A QUE MUESTRE LA PANTALLA DE MOVIMIENTOS
//-----------------------------------------------------------------------------------------------------------------------
		// LO SIGUIENTE DEBE DEJAR EL CURSOR EN EL CAMPO 'FECHA'
		if (selectProdConsMov) { // SI DEBE SELECCIONAR EL "PROD" EN LA PANTALLA DE CONSULTA DE MOVIMIENTOS
			textoEnPantalla = this.seleccionarDato(tipoProd, "PROD", "CUENTA   NRO", StratusBase.MODE_LETTER);
			this.tab(1);
			this.borrarValCampo();
			if (numProducto.length() > TAM_NUM_CTA) // SI EL TAMAÑO SUPERA LO PERMITIDO TOMA EL LADO DERECHO
				numProducto = Util.right(numProducto, TAM_NUM_CTA);
			this.paste(numProducto);
			if (numProducto.length() < TAM_NUM_CTA) // NO SE HA MOVIDO AL CAMPO DE LA FECHA: SE HACE TAB
				this.tab(1);
		} else
			this.tab(2);
//-----------------------------------------------------------------------------------------------------------------------
		// NO SE INGRESA 'FECHA', YA QUE SE CONSULTA LA FECHA ACTUAL
		this.tab(1);
//-----------------------------------------------------------------------------------------------------------------------
		List<MovimientoStratus> listaMovs = new ArrayList<MovimientoStratus>();
		this.ctrlX(1); // POR DEFECTO EL PRIMER VENT ES [MovimientoStratus.VENT_INDIC]
		textoEnPantalla = this.ubicarPantallaConLastMovimiento();
		if (textoEnPantalla == null) {
			this.escapeQ(1); // DEJA LA PANTALLA DE STRATUS EN LA PANTALLA DONDE SE HIZO LA CONSULTA DEL
								// PRODUCTO
			this.returnInicio(); // RETORNA AL MENÚ
			return listaMovs; // NO HAY MOVIMIENTOS
		}
		// SI LLEGA A ESTE PUNTO HAY MOVIMIENTOS PARA EXTRAER
		String ventActual;
		String[] arrayLineas;
		String[] arrVents = Util.removeDuplicates(arrayVents); // GARANTIZA QUE SÓLO VENGA 1 VEZ CADA "VENT"
		int numMov, totalVents = arrVents.length, numPantalla = 1, posVent, firstReng = 0, lastReng = 0,
				numMovTotal = 0;
		boolean enConsMovsInic, tomoEvidencia, enPantallaVent, noIncluir, terminarBusqueda = false;
		String nbEvidence, lastPantalla, tipoMov;
		List<Integer> listaRenglonMovNoIncluir;
		// CICLO MIENTRAS SE TERMINE LA BÚSQUEDA - VA PANTALLA A PANTALLA : OJO: LA
		// LÓGICA ES UN POCO DIFERENTE,
		// PORQUE SE VA DEL FINAL AL INICIO (HACIA ATRÁS), PORQUE SE BUSCAN LOS ÚLTIMOS
		// MOVIMIENTOS DEL PRODUCTO
		do {
			ventActual = MovimientoStratus.VENT_INDIC; // SIEMPRE SERÁ EL PRIMER "VENT"
			// LA PANTALLA 1 YA ESTÁ EN LA CONSULTA, PARA EL RESTO SE GARANTIZA QUE SE HAGA
			// LA CONSULTA
			if (numPantalla > 1 && totalVents != 0) {
				lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
				this.ctrlX(1); // ALT-F1 : CONSULTAR
				textoEnPantalla = this.readAlCambio(lastPantalla);
			}
			enPantallaVent = true; // INDICA QUE YA ESTÁ EN LA PANTALLA QUE MUESTRA LA CONSULTA DEL "VENT"
			enConsMovsInic = true;
			// LA CONSULTA DEL "VENT" [MovimientoStratus.VENT_INDIC] TOMA TODOS LOS
			// RENGLONES
			posVent = -1; // EMPIEZA DESDE [MovimientoStratus.VENT_INDIC]
			listaRenglonMovNoIncluir = new ArrayList<Integer>(); // DE LA CONSULTA ACTUAL NO HAY MOVIMIENTOS A NO
																	// INCLUIR
//-----------------------------------------------------------------------------------------------------------------------
			// CICLO DE LOS VENT CONSULTADOS, DESDE MovimientoStratus.VENT_INDIC HASTA LOS
			// EXISTENTES EN [arrVents]
			do {
				numMov = numMovTotal; // EL ELEMENTO DE LA LISTA QUE CONTIENE EL MOVIMIENTO
				if (!enPantallaVent) { // NO ESTÁ EN LA PANTALLA DEL VENT
					lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
					this.ctrlX(1); // MUESTRA LOS DATOS
					if (ventActual.equals(MovimientoStratus.VENT_TAUTO))
						this.ctrlX(1); // SE DEBE HACER DOBLE VEZ
					textoEnPantalla = this.readAlCambio(lastPantalla);
					enConsMovsInic = false;
				}
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
				if (arrayLineas[RENG_INICIO_MOVS + 1].trim().isEmpty()) { // LÍNEA 2 DE MOVIMIENTOS ES VACÍA
					terminarBusqueda = true;
					break; // YA NO HAY MÁS MOVIMIENTOS PARA CONSULTAR
				}
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// LA CONSULTA DEL "VENT" [MovimientoStratus.VENT_INDIC] TOMA TODOS LOS
				// RENGLONES, SE RECONOCE PORQUE
				// [lastReng] ES CERO, PARA LOS OTROS DESDE Y HASTA DONDE HAYA QUEDADO
				// ALMACENADO
				if (enConsMovsInic) { // = true;lastReng == 0) {
					// IDENTIFICA EL RENGLÓN EN DONDE ESTÁ EL ÚLTIMO MOVIMIENTO (PRIMERO A TOMAR):
					// LA PRIMERA PANTALLA
					// TOMA DESDE EL ÚLTIMO MOVIMIENTO, DESPUÉS DESDE EL PENÚLETIMO PORQUE EL ÚLTIMO
					// ES EL PRIMERO DE
					// LA PANTALLA YA CONSULTADA
					lastReng = RENG_FIN_MOVS - 1;
					if (numPantalla == 1)
						lastReng = RENG_FIN_MOVS;
					firstReng = RENG_INICIO_MOVS;
				}
				tomoEvidencia = false; // NO HA TOMADO EVIDENCIA DE LA PANTALLA ACTUAL
				nbEvidence = ""; // INICIALIZACIÓN
				boolean tomarMov = true;
				for (int renglon = lastReng; renglon >= firstReng; renglon--) {
					if (arrayLineas[renglon].trim().isEmpty() && enConsMovsInic) { // ESTÁ EN LA CONSULTA DEL PRIMER
																					// VENT
						lastReng = renglon - 1;
						if (numPantalla != 1)
							// CUANDO LA PANTALLA NO ES LA ÚLTIMA(1) LOS MOVIMIENTOS SE TOMAN DESDE EL
							// PENÚLTIMO PERO AL
							// NO HABER PENÚLTIMO, CUANDO ENCUENTRE EL ÚLTIMO MOVIMIENTO NO SERÁ EL
							// PENÚLTIMO
							tomarMov = false;
						continue;
					}
					if (!tomarMov) {
						tomarMov = true; // PARA LOS SIGUIENTES
						lastReng--; // PARA QUE TOME EL PENÚLTIMO
						continue;
					}
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// ALMACENA LA EVIDENCIA SI NO SE HA TOMADO
					if (!tomoEvidencia) {
						nbEvidence = this.saveEvidence("ConsultaUltMovs_" + numPantalla + "_" + ventActual);
						tomoEvidencia = true;
					}
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// SE EXCLUYEN LOS MOVIMIENTOS CANCELADOS O LOS QUE NO CORRESPONDAN A DÉBITOS NI
					// CRÉDITOS
					if (posVent == -1) {
						tipoMov = Util.mid(arrayLineas[renglon], 28, 4);
						// PARA LA VENTANA "INIC" SE SABE QUE ES CANCELADO PORQUE EN LA COLUMNA "IND"
						// HAY UNA "C"
						noIncluir = Util.mid(arrayLineas[renglon], 74, 3).trim().toUpperCase().equals("C")
								|| (!CatTipoMovimiento.esNotaCredito(tipoMov)
										&& !CatTipoMovimiento.esNotaDebito(tipoMov));
						if (noIncluir) // ALMACENA EN LA LISTA
							listaRenglonMovNoIncluir.add(renglon);
					} else // EN LAS OTRAS VENTANAS SE SABE QUE ES CANCELADO PORQUE ESTÁ EN
							// [listaRenglonMovCancelado]
						noIncluir = listaRenglonMovNoIncluir.contains(renglon);
					if (noIncluir)
						continue;
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// ALMACENA INFORMACIÓN EN [listaMovs]
					if (posVent == -1) {
						listaMovs.add(new MovimientoStratus()); // CREA EL ESPACIO EN LA LISTA
						listaMovs.get(numMov).setProducto(this.tipoCtaReal, this.numProdCompleto);
						listaMovs.get(numMov).setNumRenglon(renglon);
					}
					listaMovs.get(numMov).setearDatosXVent(ventActual, arrayLineas[renglon]);
					listaMovs.get(numMov).addEvidence(nbEvidence);
					numMov++; // INCREMENTA EL NÚMERO DEL MOVIMIENTO
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					if (listaMovs.size() == numMovimientos) { // ENCONTRÓ EL TOTAL DE MOVIMIENTOS
						firstReng = renglon; // PARA QUE LOS OTROS VENT TOMEN ESE DATO HASTA DONDE DEBEN LLEGAR
						terminarBusqueda = (posVent == totalVents - 1);
					}
				}
				posVent++;
				if (posVent < totalVents)
					ventActual = arrVents[posVent];
				enPantallaVent = false; // NO ESTÁ EN LA PANTALLA DEL "VENT" [ventActual]
			} while (posVent < totalVents && !terminarBusqueda);
//-----------------------------------------------------------------------------------------------------------------------
			// SI NO SE TERMINA LA BÚSQUEDA SE CONSULTA LA ANTERIOR PÁGINA
			if (!terminarBusqueda) {
				this.ctrlX(3); // ALT-F3 : PAG ANT
				numPantalla++;
				numMovTotal = numMov;
				if (totalVents == 0) // SÓLO SE REQUIERE LA INFORMACIÓN DE LA VENTA 'INDIC', TOCA LEER LA PANTALLA
					textoEnPantalla = this.readAlCambio(textoEnPantalla);
			}
		} while (!terminarBusqueda);
//-----------------------------------------------------------------------------------------------------------------------
		this.escapeQ(1); // DEJA LA PANTALLA DE STRATUS EN LA PANTALLA DONDE SE HIZO LA CONSULTA DE LOS
							// MOVIMIENTOS
		this.returnInicio();
//-----------------------------------------------------------------------------------------------------------------------
		return listaMovs;
	}

//***********************************************************************************************************************
	/**
	 * Hace la consulta de los datos y los movimientos correspondientes al
	 * [tipoProducto] y [numProducto] recibidos, lo intenta hacer por CONSULTA
	 * MAESTRA si [tipoProducto] corresponde a [CTA_CORRIENTE] o [CTA_AHORROS] o si
	 * no se envió información de [datosTitular].<br>
	 * Cuando se reciben los [datosTitular] se llega a la pantalla de CONSULTA
	 * MOVIMIENTO a través de la pantalla [PT_CONSULTA_PORTAF_NIT].<br>
	 * Los datos del producto sólo se retornan si se trata de [CTA_CORRIENTE] o
	 * [CTA_AHORROS], NO se recibe información en [datosTitular] y SÍ se recibe
	 * información en [datosCta].
	 * 
	 * @param tipoProducto      - Tipo del producto, debe ser como se consulta por
	 *                          MAESTRA: AH / CC / DE y si no es ninguno de estos
	 *                          valores, debe ser como se consulta por CONSUTA
	 *                          MOVIMIENTO: AHD / FDH / FMS / ADQ...
	 * @param numProducto       - Número del producto al que se le consultan los
	 *                          movimientos
	 * @param arrayVents        - Ventanas a revisar de los movimientos. En este
	 *                          arreglo NO debe incluirse el VENT inicial que es
	 *                          [MovimientoStratus.VENT_INDIC], puede venir en
	 *                          [null] y en tal caso tomará sólo el VENT inicial.
	 * @param fechaConsulta     - Date que contiene la fecha de consulta de los
	 *                          movimientos.
	 * @param arrFechaHora      - Array que contiene las fechas (mmdd) o las fechas
	 *                          y horas (mmdd hhmm ) de los movimientos que se
	 *                          buscan.
	 * @param excluirCancelados - Excluye los movimientos con IND en "C" que
	 *                          corresponden a los cancelados
	 * @param incluirSaldos     - Indica si se va a hacer consulta de saldos, en tal
	 *                          caso retorna en las primeras posiciones del array de
	 *                          String del retorno en l aposiicón 0 : 0-Saldo
	 *                          Disponible, el 1-Saldo Total, 2-#CtaCentralizadora.
	 * @param datos             - Datos a extraer de la cuenta. Cada dato recibido
	 *                          debe corresponder al <b>label del dato</b> como se
	 *                          muestra en Stratus en la pantalla "C O N S U L T A D
	 *                          E M A E S T R A S".
	 * @param datosTitular      - Si se incluye el dato, se esperan 2: Tipo de
	 *                          documento y número de documento del titular del
	 *                          producto al que se le consultan los movimientos,
	 *                          estos datos son requeridos cuando el producto NO es
	 *                          cuenta de ahorros ni corriente, porque la búsqueda
	 *                          se hace por consulta yendo a
	 *                          [PT_CONSULTA_PORTAF_NIT].
	 * @return - Arreglo de dos elementos:<br>
	 *         0 - String[] con los valores de los datos consultados de la cuenta.
	 *         [null] si no hubo consulta de datos. En caso contrario:<br>
	 *         + Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         + Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado.<br>
	 *         + Si la consulta NO retorna ERROR por ninguna consulta, retorna:<br>
	 *         incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora (si tiene), 3-..Datos<br>
	 *         incluirSaldos = false >> 0-..Datos<br>
	 *         1 - List<MovimientoStratus> los movimientos encontrados.
	 */
	protected Object[] getDatosYMovimientos(String tipoProducto, String numProducto, String[] arrayVents,
			Date fechaConsulta, String[] arrFechaHora, boolean excluirCancelados, boolean incluirSaldos,
			String[] datosCta, String[] datosTitular) throws Exception {

		boolean selectProdConsMov = false; // SELECCIONA EL PRODUCTO EN "C O N S U L T A M O V I M I E N T O"
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		Object[] arrayReturn = new Object[2]; // 0-Array String con los datos de la cuenta, 1-List<MovimientoStratus>
//-----------------------------------------------------------------------------------------------------------------------
		// PARA CUENTA DE AHORROS O CORRIENTE Y QUE NO TRAIGA DATOS DEL TITULAR , HACE
		// LA CONSULTA DEL PRODUCTO EN
		// [PT_CONSULTA_MAESTRAS]
		if ((tipoProducto.equals(CTA_CORRIENTE) || tipoProducto.equals(CTA_AHORROS))
				&& (datosTitular == null || datosTitular.length == 0 || datosTitular[0] == null)) {
			this.irConsultaMaestra();
			arrayReturn[0] = this.getSaldosDatosCta(tipoProducto, numProducto, incluirSaldos, null, datosCta);
			if (this.errorConsultaSaldos) {
				this.returnInicio();
				return arrayReturn; // HUBO ERROR NO TIENE PORQUÉ SEGUIR CON LA CONSULTA
			}
		}
//-----------------------------------------------------------------------------------------------------------------------
		else {
			if (datosTitular == null || datosTitular.length == 0 || datosTitular[0] == null) {
				this.irConsultaMaestra(); // DEBE IR A CONSULTA MAESTRAS Y LUEGO ENTRAR DE UNA A LA CONSULTA DE MOVS
				selectProdConsMov = true;
			} else { // SI SE CUENTA CON DATOS DEL TITULAR HACE LA CONSULTA DEL PRODUCTO EN
						// [PT_CONSULTA_PORTAF_NIT]
				String tipoDoc = StratusProductos.getTipoDocumentoConsPortafolio(datosTitular[0]); // GARANTIZA EL DATO
				String numDoc = datosTitular[1];
				this.irConsultaPortafolio();
				// 0:Error, 1:Pantalla
				String[] arrCursorEnProd = this.ubicarCursorEnProducto(tipoDoc, numDoc, tipoProducto, numProducto,
						true);
				if (!arrCursorEnProd[0].isEmpty()) {
					this.returnInicio();
					arrayReturn[0] = new String[] { arrCursorEnProd[0] };
					return arrayReturn;
					// throw new Exception("STRATUS ERROR -- " + arrCursorEnProd[0]);
					// @SANDRA: SE COMENTAREA EL ANTERIOR [throw new] PARA QUE NO MATE LAS
					// EJECUCIONES (10/11/2023)
					// SE HACE MÁS POR SU USO EN CONSULTA [getInformationCRED] DE YHON
				}
//-----------------------------------------------------------------------------------------------------------------------
				if (!tipoProducto.equals(CTA_CORRIENTE) && !tipoProducto.equals(CTA_AHORROS)) {
					int totalDatos = 0;
					// NO SE PUEDEN CONSULTAR DATOS SI NO ES CUENTA DE AHORROS O CORRIENTE
					if (datosCta != null && datosCta[0] != null)
						totalDatos = datosCta.length;
					int numDatosSaldos = incluirSaldos ? 4 : 0;
					String[] arrDatosEmpty = new String[numDatosSaldos + totalDatos];
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					int posInic = 0;
					if (incluirSaldos) {
						posInic = 3;
						this.ctrlX(1); // PARA CONSULTAR SALDOS
						String pantallaSaldos = this.read();
						this.saveEvidence("SaldoProducto-" + numProducto);
						String[] arrSaldos = this.getDatosPantallaSaldos(pantallaSaldos, tipoProducto);
						// 0-Saldo Disponible, 1-Valor Mora, 2-Valor Cuota, 3-Pago por aplicar
						arrDatosEmpty[2] = arrDatosEmpty[3] = "";
						if (tipoProducto.equals(CREDITO)) {
							arrDatosEmpty[0] = arrSaldos[2];
							arrDatosEmpty[1] = arrSaldos[4];
							arrDatosEmpty[2] = arrSaldos[6];
							arrDatosEmpty[3] = arrSaldos[8];
						} else if (tipoProducto.equals(TARJETA_CREDITO)) {
							arrDatosEmpty[0] = arrSaldos[0];
							arrDatosEmpty[1] = arrSaldos[1];
							arrDatosEmpty[2] = arrSaldos[2];
							arrDatosEmpty[3] = arrSaldos[3];
						} else if (tipoProducto.equals(FONDO_INVERSION)) {
							arrDatosEmpty[0] = arrSaldos[3];
							arrDatosEmpty[1] = arrSaldos[1];
						}
						this.escapeQ(1); // RETORNA A CONSULTA POR NIT, TOCA DEJAR EL CURSOR EN EL PRODUCTO
						// AL RETORNAR QUEDA EN EL NÚMERO DE DOCUMENTO, NO SE PUEDE DAR ENTER, TOCA:
						// ABAJO, TAB, TAB, ARRIBA: PARA DEJAR EL CURSOR EN EL PRIMER PRODUCTO
						this.down(1);
						this.tab(2);
						this.up(1);
						// EL PRIMER [false] ES PARA QUE NO GUARDE EVIDENCIA Y EL SEGUNDO ES PARA
						// INDICAR QUE NO ES LA
						// PRIMERA CONSULTA, PORQUE YA SE HABÍA CONSULTADO
						this.ubicarCursorEnProducto(tipoDoc, numDoc, tipoProducto, numProducto, false, false);
					}
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// CUANDO NO ES AHORROS NI CORRIENTE, NO HAY FORMA DE CONSULTAR DATOS, SE
					// RETORNA VACÍO
					for (int posArr = posInic; posArr < totalDatos; posArr++) {
						arrDatosEmpty[posArr] = "";
					}
					arrayReturn[0] = arrDatosEmpty;
				}
//-----------------------------------------------------------------------------------------------------------------------
				else if (datosCta != null && datosCta[0] != null) { // ES AHORROS / CORRIENTE Y DEBE INCLUIR DATOS
					this.ctrlX(2); // PARA CONSULTAR DATOS
					this.saveEvidence("DatosCta-" + tipoProducto + this.numProdCompleto);
					String pantallaDatosCta = this.read();
					arrayReturn[0] = this.getSaldosDatosCta(tipoProducto, numProducto, incluirSaldos, pantallaDatosCta,
							datosCta);
					this.numEscapeQInicio++; // PORQUE HUBO INGRESO A LOS DATOS ANTES DE IR A MOVIMIENTOS
					// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
					// CUANDO SE TRATE DE UNA CUENTA MIGRADA SE EXTRAE EL DATO DE LA CTA ASOCIADA
					boolean esMigrada = (tipoProducto.equals(CTA_AHORROS) || tipoProducto.equals(CTA_CORRIENTE))
							&& esCuentaMigrada(this.numProdCompleto);
					if (esMigrada) { // MIRA SI ALMACENA LA CUENTA MIGRADA AL MAP [dicCtasAsoc_Migradas]
						String keyDic = tipoProducto + "-" + this.numProdCompleto;
						if (!dicCtasAsoc_Migradas.containsKey(keyDic))
							dicCtasAsoc_Migradas.put(keyDic,
									Util.getTextoEntre(pantallaDatosCta, "DATOS PERSONALES DEL PRODUCTO :", "NIT"));
					}
				}
			}
		}
//-----------------------------------------------------------------------------------------------------------------------
		this.ctrlX(4); // F4 - MOVIMIENTOS : PARA CONSULTAR LOS MOVIMIENTOS
		String textoEnPantalla = this.read(PT_CONSULTA_MOVIMIENTO); // ESPERA A QUE MUESTRE LA PANTALLA DE MOVIMIENTOS
//-----------------------------------------------------------------------------------------------------------------------
		// LO SIGUIENTE DEBE DEJAR EL CURSOR EN EL CAMPO 'FECHA'
		if (selectProdConsMov) { // SI DEBE SELECCIONAR EL "PROD" EN LA PANTALLA DE CONSULTA DE MOVIMIENTOS
			textoEnPantalla = this.seleccionarDato(tipoProducto, "PROD", "CUENTA   NRO", StratusBase.MODE_LETTER);
			this.tab(1);
			this.borrarValCampo();
			if (numProducto.length() > TAM_NUM_CTA) // SI EL TAMAÑO SUPERA LO PERMITIDO TOMA EL LADO DERECHO
				numProducto = Util.right(numProducto, TAM_NUM_CTA);
			this.paste(numProducto);
			if (numProducto.length() < TAM_NUM_CTA) // NO SE HA MOVIDO AL CAMPO DE LA FECHA: SE HACE TAB
				this.tab(1);
		} else
			this.tab(2);
//-----------------------------------------------------------------------------------------------------------------------
		// YA ESTÁ EN EL CAMPO 'FECHA' - LO SIGUIENTE DEBE DEJAR EL CURSOR EN EL CAMPO
		// 'VENT'
		boolean evalSoloFecha = (arrFechaHora[0].length() == 4); // SÓLO TIENE 'mmdd'
		String fechaHoy = Util.dateToString("yyyymmdd");
		String fechaIngresar = Util.dateToString(fechaConsulta, "yyyymmdd");
		if (fechaIngresar.equals(fechaHoy))
			this.tab(1);
		else // SE DEBE CAMBIAR LA FECHA
			this.paste(fechaIngresar); // DEJA EL CURSOR EN EL CAMPO "VENT"
//-----------------------------------------------------------------------------------------------------------------------
		List<MovimientoStratus> listaMovs = new ArrayList<MovimientoStratus>();
		this.ctrlX(1); // POR DEFECTO EL PRIMER VENT ES [MovimientoStratus.VENT_INDIC]
		textoEnPantalla = this.ubicarPantallaCon1erMovimientoBuscado(arrFechaHora, evalSoloFecha);
		String lastPantalla;
		if (textoEnPantalla == null) {
			this.escapeQ(1); // DEJA LA PANTALLA DE STRATUS EN LA PANTALLA DONDE SE HIZO LA CONSULTA DEL
								// PRODUCTO
			this.returnInicio();
			arrayReturn[1] = listaMovs; // NO HAY MOVIMIENTOS
			return arrayReturn;
		}
		// SI LLEGA A ESTE PUNTO HAY MOVIMIENTOS PARA EVALUAR
		int ultPos = arrFechaHora.length - 1;
		String horasEvi = Util.right(arrFechaHora[0].trim(), 4) + "a" + Util.right(arrFechaHora[ultPos].trim(), 4)
				+ "_"; // HHMMaHHMM_
		String fechaHoraMov, ventActual;
		String[] arrayLineas;
		String[] arrVents = Util.removeDuplicates(arrayVents); // GARANTIZA QUE SÓLO VENGA 1 VEZ CADA "VENT"
		int numMov, totalVents = arrVents.length, numPantalla = 1, posVent, firstReng, lastReng, numMovTotal = 0;
		boolean tomoEvidencia, yaTomoMovs = false, terminarBusqueda = false, enPantallaVent, esMovCancelado;
		String nbEvidence;
		List<Integer> listaRenglonMovCancelado;
		do { // CICLO MIENTRAS NO SE TERMINE LA BÚSQUEDA - VA PANTALLA A PANTALLA
			ventActual = MovimientoStratus.VENT_INDIC; // SIEMPRE SERÁ EL PRIMER "VENT"
			enPantallaVent = true; // INDICA QUE YA ESTÁ EN LA PANTALLA QUE MUESTRA LA CONSULTA DEL "VENT"
			// LA PANTALLA 1 YA ESTÁ EN LA CONSULTA, PARA EL RESTO SE GARANTIZA QUE SE HAGA
			// LA CONSULTA
			if (numPantalla > 1 && totalVents != 0) {
				lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
				this.ctrlX(1); // ALT-F1 : CONSULTAR
				textoEnPantalla = this.readAlCambio(lastPantalla);
			}
			// LA CONSULTA DEL "VENT" [MovimientoStratus.VENT_INDIC] TOMA TODOS LOS
			// RENGLONES
			firstReng = lastReng = 0;
			posVent = -1; // EMPIEZA DESDE [MovimientoStratus.VENT_INDIC]
			listaRenglonMovCancelado = new ArrayList<Integer>(); // DE LA CONSULTA ACTUAL NO HAY CANCELADOS
			do { // CICLO DE LOS VENT CONSULTADOS, DESDE MovimientoStratus.VENT_INDIC HASTA LOS
					// EXISTENTES EN [arrVents]
				numMov = numMovTotal; // EL ELEMENTO DE LA LISTA QUE CONTIENE EL MOVIMIENTO
				if (!enPantallaVent) { // NO ESTÁ EN LA PANTALLA DEL VENT
					lastPantalla = this.seleccionarDato(ventActual, "VENT", "CONC", MODE_LETTER);
					this.ctrlX(1); // MUESTRA LOS DATOS
					if (ventActual.equals(MovimientoStratus.VENT_TAUTO))
						this.ctrlX(1); // SE DEBE HACER DOBLE VEZ
					textoEnPantalla = this.readAlCambio(lastPantalla);
				}
				arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
				// LA CONSULTA DEL "VENT" [MovimientoStratus.VENT_INDIC] TOMA TODOS LOS
				// RENGLONES, SE RECONOCE PORQUE
				// [firstReng] ES CERO, PARA LOS OTROS DESDE Y HASTA DONDE HAYA QUEDADO
				// ALMACENADO
				if (firstReng == 0) {
					// IDENTIFICA EL RENGLÓN EN DONDE ESTÁ EL 1er MOVIMIENTO: LA PRIMERA PANTALLA
					// TOMA DESDE EL 1er
					// MOVIMIENTO, DESPUÉS DESDE EL 2do PORQUE EL 1ro ES EL ÚLTIMO DE LA ANTERIOR
					// PANTALLA:
					firstReng = RENG_INICIO_MOVS + 1;
					if (numPantalla == 1)
						firstReng = this.RENG_PRIMER_MOV;
					lastReng = RENG_FIN_MOVS;
				}
				tomoEvidencia = false; // NO HA TOMADO EVIDENCIA DE LA PANTALLA ACTUAL
				nbEvidence = ""; // INICIALIZACIÓN
				for (int renglon = firstReng; renglon <= lastReng; renglon++) {
					if (arrayLineas[renglon].trim().isEmpty()) { // YA NO HAY MÁS MOVIMIENTOS
						if (posVent == totalVents - 1 || renglon == firstReng)
							terminarBusqueda = true;
						break;
					}
//-----------------------------------------------------------------------------------------------------------------------
					// SE EVALÚA SI SE DEBEN EXCLUIR CANCELADOS, EN TAL CASO SE MIRA SI EL
					// MOVIMIENTO ESTÁ CANCELADO
					if (excluirCancelados) {
						// PARA LA VENTANA "INIC" SE SABE QUE ES CANCELADO PORQUE EN LA COLUMNA "IND"
						// HAY UNA "C"
						if (posVent == -1) {
							esMovCancelado = Util.mid(arrayLineas[renglon], 74, 3).trim().toUpperCase().equals("C");
							if (esMovCancelado) // ALMACENA EN LA LISTA
								listaRenglonMovCancelado.add(renglon);
						} else // EN LAS OTRAS VENTANAS SE SABE QUE ES CANCELADO PORQUE ESTÁ EN
								// [listaRenglonMovCancelado]
							esMovCancelado = listaRenglonMovCancelado.contains(renglon);
						// SI EL MOVIMIENTO ES CANCELADO, NO SE EVALÚA, CONTINÚA CON EL SIGUIENTE
						if (esMovCancelado)
							continue;
					}
//-----------------------------------------------------------------------------------------------------------------------
					// EXTRAE LA INFORMACIÓN DEL MOVIMIENTO CONTRA EL QUE SE COMPARARÁ:
					if (evalSoloFecha)
						fechaHoraMov = Util.mid(arrayLineas[renglon], 2, 4); // "MMDD"
					else
						fechaHoraMov = Util.mid(arrayLineas[renglon], 2, 10); // "MMDD HHMM "
					// SI arrFechaHora[0] <= fechaHoraMov <= arrFechaHora[ultPos] : TOMA MOVIMIENTO
					if (arrFechaHora[0].compareTo(fechaHoraMov) <= 0
							&& fechaHoraMov.compareTo(arrFechaHora[ultPos]) <= 0) {
						// ALMACENA LA EVIDENCIA SI NO SE HA TOMADO
						if (!tomoEvidencia) {
							nbEvidence = this.saveEvidence("ConsultaMovs_" + horasEvi + numPantalla + "_" + ventActual);
							tomoEvidencia = true;
						}
						// ALMACENA INFORMACIÓN EN [listaMovs]
						if (!yaTomoMovs)
							firstReng = renglon;
						yaTomoMovs = true;
						if (posVent == -1)
							listaMovs.add(new MovimientoStratus()); // CREA EL ESPACIO EN LA LISTA
						listaMovs.get(numMov).setearDatosXVent(ventActual, arrayLineas[renglon]);
						listaMovs.get(numMov).setProducto(this.tipoCtaReal, this.numProdCompleto);
						listaMovs.get(numMov).setNumRenglon(renglon);
						listaMovs.get(numMov).addEvidence(nbEvidence);
						numMov++; // INCREMENTA EL NÚMERO DEL MOVIMIENTO
						// TERMINA BÚSQUEDA SI ESTÁ EN EL ÚLTIMO "VENT", EN ÚLTIMO RENGLÓN Y NO ES
						// [RENG_FIN_MOVS]
						terminarBusqueda = (posVent == totalVents - 1 && renglon == lastReng
								&& lastReng != RENG_FIN_MOVS);
					}
					// SI NO TOMA EL MOVIMIENTO PERO [yaTomoMovs] Y NO SE ESTÁ EN EL ÚLTIMO VENT O
					// EL ÚLTIMO RENGLÓN A
					// EVALUAR ES MENOR AL PRIMER RENGLÓN ES PORQUE NO SE DEBEN BUSCAR MÁS MOVS =>
					// TERMINA LA BÚSQUEDA
					else if (yaTomoMovs) {
						lastReng = renglon - 1; // EL ÚLTIMO RENGLÓN A EVALUAR
						if (posVent == totalVents - 1 || lastReng < firstReng)
							terminarBusqueda = true;
						break;
					}
				}
				posVent++;
				if (posVent < totalVents)
					ventActual = arrVents[posVent];
				enPantallaVent = false; // NO ESTÁ EN LA PANTALLA DEL "VENT" [ventActual]
			} while (posVent < totalVents && !terminarBusqueda);
			// SI NO SE TERMINA LA BÚSQUEDA SE CONSULTA LA SIGUIENTE PÁGINA
			if (!terminarBusqueda) {
				this.ctrlX(2); // ALT-F2 : PAG SIG
				numPantalla++;
				numMovTotal = numMov;
				if (totalVents == 0) // SÓLO SE REQUIERE LA INFORMACIÓN DE LA VENTA 'INDIC', TOCA LEER LA PANTALLA
					textoEnPantalla = this.readAlCambio(textoEnPantalla);
			}
		} while (!terminarBusqueda);
//-----------------------------------------------------------------------------------------------------------------------
		this.escapeQ(1); // DEJA LA PANTALLA DE STRATUS EN LA PANTALLA DONDE SE HIZO LA CONSULTA DE LOS
							// MOVIMIENTOS
		this.returnInicio();
//-----------------------------------------------------------------------------------------------------------------------
		arrayReturn[1] = listaMovs;
		return arrayReturn;
	}
//***********************************************************************************************************************

	// **@NARLI TEMPORAL
	private String saldoPignGMF;

	public String getSaldoPignGMF() {
		return saldoPignGMF;
	}

	/**
	 * Este método retorna los datos de la cuenta que corresponde a [tipoCta] y
	 * [numCta]. Lo datos a retornar corresponde a los saldos si [incluirSaldos] es
	 * [true] y a los [datos] indicados.<br>
	 * <b>Pre-requisito:</b> La pantalla en Stratus se encuentra en la CONSULTA DE
	 * MAESTRAS
	 * 
	 * @param pantallaDatosCta - Si viene en null es porque debe hacer el ingreso de
	 *                         los datos de la cuenta, si no, es porque ya se cuenta
	 *                         con la pantalla de los datos de la cuenta y no se
	 *                         debe hacer ingreso.
	 * @return Retorna un arreglo de String con la información que se busca:<br>
	 *         - Si hay problemas con la cuenta y no se pueden consultar sus datos,
	 *         el String[] tendrá un único elemento que indica el error presentado y
	 *         deja marca en [this.errorConsulta].<br>
	 *         - Si se incluyen saldos y por alguna razón se presentó ERROR en su
	 *         consulta, el String[] tendrá un único elemento que indica el error
	 *         presentado y deja marca en [this.errorConsulta].<br>
	 *         - Si la consulta NO retorna ERROR por ninguna consulta, retorna:<br>
	 *         * incluirSaldos = true >> 0-Saldo Disponible, 1-Saldo Total,
	 *         2-#CtaCentralizadora (si tiene), 3-...Datos<br>
	 *         * incluirSaldos = false >> 0-...Datos consultados
	 */
	private String[] getSaldosDatosCta(String tipoCta, String numCta, boolean incluirSaldos, String pantallaDatosCta,
			String... datos) throws Exception {

		this.errorConsultaSaldos = false;
		boolean guardarEvidDatos = (datos != null && datos.length != 0);
		if (pantallaDatosCta == null)
			pantallaDatosCta = this.ingresarDatosCta(tipoCta, numCta, guardarEvidDatos);
		tipoCta = this.tipoCtaReal; // PARA GARANTIZAR QUE TOME LA REAL
		if (pantallaDatosCta.length() <= TAM_MAX_LINEA) { // LA CONSULTA DE LA CUENTA PRESENTÓ ERROR
			this.errorConsultaSaldos = true;
			return new String[] { pantallaDatosCta };
		}
		// ALISTA EL ARREGLO DE LA INFORMACIÓN DE LOS SALDOS
		String[] arrSaldos = new String[0]; // INICIALIZA COMO SI NO HUBIERA SALDOS PARA INCLUIR
		if (incluirSaldos) { // HACE LA CONSULTA DE LOS SALDOS
			String numCtaCent = "";
			String pantallaSaldo = this.getPantallaSaldoCta(tipoCta, numCta, true);
			if (pantallaSaldo.contains(CENTRALIZADORA)) { // NO HAY SALDO Y SE DEBE CONSULTAR DE LA CENTRALIZADORA
				numCtaCent = Util.getTextoEntre(pantallaSaldo, CENTRALIZADORA, "|");
				this.ingresarDatosCta(tipoCta, numCtaCent, guardarEvidDatos);
				pantallaSaldo = this.getPantallaSaldoCta(tipoCta, numCtaCent, true);
			}
			// SI NO ENTRA A LA PANTALLA DE SALDOS, DEJA INFORMACIÓN DEL ERROR:
			if (!pantallaSaldo.toUpperCase().contains("SALDO TOTAL")) {
				String lineaError = this.getLineaError(pantallaSaldo, false);
				this.errorConsultaSaldos = true;
				return new String[] { lineaError }; // ERROR
			}
			// ENCONTRÓ INFORMACIÓN DE SALDOS
			arrSaldos = new String[3];
			arrSaldos[2] = numCtaCent; // 0-Saldo disponible, 1-Saldo Total
			if (tipoCta.equals(CTA_AHORROS)) {
				arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Disponible:", "\n"), 2);
				arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "Saldo Total :", "\n"), 2);
				try { // @NARLI - EXTRACCIÓN DEL DATO DE FORMA TEMPORAL, EN TRY POR SI NO VIENE EL
						// DATO EN LA PANTALLA DE SALDOS
					saldoPignGMF = Util.getTextoEntre(pantallaSaldo, "Saldo Pign. GMF:", "\n");
				} catch (Exception e) {
					// TODO: handle exception
				}
			} else { // ES [CTA_CORRIENTE]
				arrSaldos[0] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "DISPONIBLE EFECTIVO", "|"), 2);
				arrSaldos[1] = Util.toNumberInString(Util.getTextoEntre(pantallaSaldo, "SALDO TOTAL", "|"), 2);
			}
		}
		// ENCONTRÓ INFORMACIÓN DE LA CUENTA, EXTRAE EL VALOR DE LOS DATOS CONSULTADOS
		// (SI LOS HAY)
		String[] arrDatos = this.getDatosCta(pantallaDatosCta, datos);
		return Util.joinArrays(arrSaldos, arrDatos);
	}

//***********************************************************************************************************************
	/**
	 * Ubica la pantalla de stratus en la primera pantalla en donde aparecen los
	 * movimientos que se están buscando.<br>
	 * Ya se realizó la consulta de los movimientos, se conoce la pantalla
	 * porque:<br>
	 * - Si [evalSoloFecha] es TRUE , se evalúa sólo la fecha, por ende es porque el
	 * primer movimiento presentado cuenta con alguna de las fechas existentes en
	 * [arrFechaHora].<br>
	 * - Si [evalSoloFecha] es FALSE, se evalúa fecha y hora, por ende es porque
	 * contiene alguno de los datos de FECHA y HORA existentes en [arrFechaHora].
	 * 
	 * @param arrFechaHora  - String con los datos de FECHA y HORA que se buscan :
	 *                      "mmdd hhmm " o<br>
	 *                      - String con los datos de FECHA que se buscan : "mmdd".
	 * @param evalSoloFecha - Indica si el array [arrFechaHora] trae sólo fechas o
	 *                      fecha y hora.
	 * @return el texto de la pantalla si se encontró movimiento, NULL en caso
	 *         contrario.
	 * @throws Exception
	 */
	private String ubicarPantallaCon1erMovimientoBuscado(String[] arrFechaHora, boolean evalSoloFecha)
			throws Exception {

		String textoEnPantalla, lineaMov, fSi;
		String[] arrayLineas;
		boolean yaValIngreso = false, hayMasMovimientos, pantallaEncontrada = false, hayMsgNoMov, hayMovs;
		int numPantalla = 1, rengPrimerMov;
		do {
			textoEnPantalla = this.read();
			arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
//-----------------------------------------------------------------------------------------------------------------------	        
			if (!yaValIngreso) {
				do { // CICLO QUE GARANTIZA LA ESPERA DE LA CONSULTA: DEBE MOSTRAR MENSAJE
						// [NO_HAY_MOVS] O DEBE MOSTRAR
						// MOVIMIENTO EN ALGUNA DE LAS LÍNEAS
					hayMsgNoMov = textoEnPantalla.contains(NO_HAY_MOVS);
					hayMovs = false; // VALOR POR DEFECTO
					if (!hayMsgNoMov) { // EVALÚA SI MOSTRÓ ALGÚN MOVIMIENTO
						for (int reng = RENG_INICIO_MOVS; reng <= RENG_FIN_MOVS; reng++) {
							if (!arrayLineas[reng].trim().isEmpty()) {
								hayMovs = true;
								this.RENG_PRIMER_MOV = reng;
								break;
							}
						}
					}
					if (!hayMsgNoMov && !hayMovs) {
						textoEnPantalla = this.read();
						arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
					} else
						yaValIngreso = true; // PARA SALIR DEL CICLO, Y PARA QUE NO VUELVA A ENTRAR
				} while (!yaValIngreso);
			}
//-----------------------------------------------------------------------------------------------------------------------	        
			Evidence.saveTemp("ConsultaMovs_" + numPantalla, this);
			// IDENTIFICA EL RENGLÓN EN DONDE ESTÁ EL 1er MOVIMIENTO:
			rengPrimerMov = RENG_INICIO_MOVS + 1;
			if (numPantalla == 1)
				rengPrimerMov = this.RENG_PRIMER_MOV;
			hayMasMovimientos = false; // ASUME QUE NO HAY HAY MOVIMIENTOS A EVALUAR
			// SI EL PRIMER MOVIMIENTO A TENER EN CUENTA (EL DE [posPrimerMov]) EXISTE:
			lineaMov = arrayLineas[rengPrimerMov].trim();
			if (evalSoloFecha) { // SE EVALÚA SÓLO LA FECHA
				fSi = Util.mid(lineaMov, 1, 4); // "MMDD"
				pantallaEncontrada = Util.itemInArray(fSi, arrFechaHora);
			} else if (!lineaMov.isEmpty()) { // SE EVALÚA FECHA Y HORA
				pantallaEncontrada = Util.itemContainsAnyArrayItem(textoEnPantalla, arrFechaHora);
				if (!pantallaEncontrada && !arrayLineas[RENG_FIN_MOVS].trim().isEmpty()) {
					fSi = Util.mid(arrayLineas[RENG_FIN_MOVS], 2, 10); // "MMDD HHMM "
					// SE PUEDE MOVER A LA SIGUIENTE PANTALLA SI LA FECHA Y HORA DEL ÚLTIMO
					// MOVIMIENTO ES MENOR A LA
					// PRIMERA FECHA Y HORA EXISTENTES EN [arrFechaHora]
					hayMasMovimientos = (fSi.compareTo(arrFechaHora[0]) <= 0);
					if (hayMasMovimientos) {
						this.ctrlX(2); // ALT-F2 : PAG SIG
						numPantalla++; // INCREMENTA EL NÚMERO DE LA PANTALLA
					}
				}
			}
		} while (!pantallaEncontrada && hayMasMovimientos);
//-----------------------------------------------------------------------------------------------------------------------
		// CUANDO LA EVIDENCIA DEBE SER TEMPORAL Y SE ENCONTRÓ UN PRIMER MOVIMIENTO LOS
		// BUSCADOS, SE LIMPIA LA
		// CARPETA DE EVIDENCIA TEMPORAL, DESECHANDO LO QUE CONTIENE
		if (CommonStratus.evidenceTemporal && pantallaEncontrada)
			Evidence.cleanTempEvidence(false);
		// CUANDO LA EVIDENCIA NO DEBE SER TEMPORAL, LOS TEMPORALES SE GUARDAN SI NO SE
		// ENCONTRARON MOVIMIENTOS
		else if (!CommonStratus.evidenceTemporal)
			Evidence.cleanTempEvidence(!pantallaEncontrada);
		// EN CASO CONTRARIO LA CARPETA DE EVIDENCIA TEMPORAL QUEDA CON LAS EVIDENCIAS
		if (!pantallaEncontrada)
			textoEnPantalla = null;
		return textoEnPantalla;
	}

//***********************************************************************************************************************
	/**
	 * Ubica la pantalla de stratus en la pantalla en donde aparece el último
	 * movimiento.<br>
	 * Ya se cuenta con la consulta pertinente de movimientos, la cual corresponde a
	 * los de la fecha actual, puede pasar que no hayan movimientos en la fecha
	 * actual, si es así, deja la pantalla en el último movimiento llevando la
	 * pantalla a la anterior.
	 * 
	 * @return el texto de la pantalla que cuenta con el último movimiento, NULL en
	 *         caso que no hayan movimientos.
	 */
	private String ubicarPantallaConLastMovimiento() throws Exception {

		String textoEnPantalla, fechaIngresar;
		String[] arrayLineas;
		boolean yaMostroResultConsulta, hayMsgNoMov, hayMovs = false, terminar;
		Date fechaConsulta = new Date(); // FECHA ACTUAL
		int veces = 1;
		do {
			textoEnPantalla = this.read();
			arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
			yaMostroResultConsulta = false;
//-----------------------------------------------------------------------------------------------------------------------	        
			if (!yaMostroResultConsulta) {
				do { // CICLO QUE GARANTIZA LA ESPERA DE LA CONSULTA: DEBE MOSTRAR MENSAJE
						// [NO_HAY_MOVS] O DEBE MOSTRAR
						// MOVIMIENTO EN LA PRIMERA LÍNEA [RENG_INICIO_MOVS]
					hayMsgNoMov = textoEnPantalla.contains(NO_HAY_MOVS);
					hayMovs = !arrayLineas[RENG_INICIO_MOVS].trim().isEmpty();
					yaMostroResultConsulta = (hayMsgNoMov || hayMovs);
					if (!yaMostroResultConsulta) {
						textoEnPantalla = this.read();
						arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
					}
				} while (!yaMostroResultConsulta);
			}
//-----------------------------------------------------------------------------------------------------------------------
			terminar = (veces == 61); // TERMINAR SI YA SE HA HECHO LA CONSULTA 61 VECES
			// CONSULTAR EL DÍA ANTERIOR: CUANDO NO SE HAN ENCONTRADO MOVIMIENTOS Y NO SE
			// DEBE TERMINAR
			if (!hayMovs && !terminar) {
				this.escapeTab(1); // PARA DEVOLVERSE AL CAMPO DE LA FECHA
				fechaConsulta = Util.dateAdd(fechaConsulta, Calendar.DATE, -1);
				fechaIngresar = Util.dateToString(fechaConsulta, "yyyymmdd");
				this.paste(fechaIngresar); // DEJA EL CURSOR EN EL CAMPO "VENT"
				this.ctrlX(1);
				veces++;
			}
		} while (!hayMovs && !terminar);
//-----------------------------------------------------------------------------------------------------------------------	        
		if (!hayMovs) { // RETORNA NULL PORQUE NO HAY MOVIMIENTOS
			Evidence.save("NoHayMovimientos", this);
			return null;
		}
//-----------------------------------------------------------------------------------------------------------------------	        
		// SI LLEGA A ESTE PUNTO ES PORQUE HAY MOVIMIENTOS: SE DEJA LA PANTALLA DONDE
		// ESTÁ EL ÚLTIMO MOVIMIENTO
		terminar = false;
		do {
			// 1. SI COMO SEGUNDO MOVIMIENTO NO SE MUESTRA NADA, ES PORQUE EL PRIMERO SE VÉ
			// EN LA ANTERIOR PÁGINA
			if (arrayLineas[RENG_INICIO_MOVS + 1].trim().isEmpty()) {
				this.ctrlX(3); // PÁGINA ANTERIOR
				Util.wait(1); // A VECES ES LENTO
				terminar = true;
				textoEnPantalla = this.read();
			}
			// 2. SI LA LÍNEA DEL ÚLTIMO MOVIMIENTO ESTÁ EN BLANCO ES PORQUE SE ESTÁ EN LA
			// PANTALLA QUE ES
			else if (arrayLineas[RENG_FIN_MOVS].trim().isEmpty())
				terminar = true;
			// 3. SI NO SE CUMPLIERON LAS CONDICIONES 1 NI 2, SE DEBE AVANZAR EN LA CONSULTA
			else {
				this.ctrlX(2);
				textoEnPantalla = this.read();
				arrayLineas = textoEnPantalla.split("\n"); // DIVIDE EL TEXTO POR "enter"
			}
		} while (!terminar);
		return textoEnPantalla;
	}

//***********************************************************************************************************************
	/**
	 * Método que adiciona el [movimiento] en [listaMovimientos] desde que
	 * corresponda a una "nota débito" o una "nota crédito" (esto se sabe usando el
	 * catálogo [CatTipoMovimiento]).<br>
	 * Dependendiendo del valor de [incluirContrapartidas] incluye o no las
	 * contrapartidas de los movimientos ya existentes en [listaMovimientos].
	 * 
	 * @param listaMovimientos      - Lista de los movimientos que se van teniendo
	 *                              en cuenta
	 * @param movimiento            - Movimiento a evaluar, para ver si se incluye
	 * @param excluirContrapartidas - Indica si se excluyen o no las
	 *                              contrapartidas:<br>
	 *                              - Si está en [true] en caso que el [movimiento]
	 *                              sea contrapartida de alguno de los movimientos
	 *                              existentes en [listaMovimientos], no adiciona el
	 *                              movimiento y además hace el borrado del
	 *                              movimiento detectado como contrapartida de la
	 *                              [listaMovimientos], porque es como si el
	 *                              movimiento realmente NO xistiera.<br>
	 *                              - Si está en [false] sólo evalúa que el
	 *                              movimiento sea Crédito o Débito.
	 */
	private void adicionarMovimientoTx(List<MovimientoStratus> listaMovimientos, MovimientoStratus movimiento,
			boolean excluirContrapartidas) {

		// SE PUEDE ADICIONAR EL MOVIMIENTO SI SU TIPO ES CRÉDITO O DÉBITO
		boolean puedeAddMov = CatTipoMovimiento.esNotaCredito(movimiento.getTipo())
				|| CatTipoMovimiento.esNotaDebito(movimiento.getTipo());
//-----------------------------------------------------------------------------------------------------------------------
		// SI SE CONTEMPLA EXCLUIR LAS CONTRAPARTIDAS, SE DEBE EVALUAR QUE EL
		// [movimiento] NO SEA CONTRAPARTIDA
		// DE LOS MOVIMIENTOS YA EXISTENTES EN [listaMovimientos]
		if (puedeAddMov && excluirContrapartidas) {
			int totalMovs = listaMovimientos.size();
			MovimientoStratus mov;
			for (int posLista = 0; posLista < totalMovs; posLista++) {
				mov = listaMovimientos.get(posLista);
				// REVISA SI EL MOVIMIENTO ENCONTRADO ES DÉBITO O CRÉDITO, PARA VER SI ES
				// CONTRAPARTIDA
				if (CatTipoMovimiento.esNotaCredito(mov.getTipo()) || CatTipoMovimiento.esNotaDebito(mov.getTipo())) {
					if (mov.isContrapartida(movimiento)) {
						puedeAddMov = false; // NO LO ADICIONA PORQUE SE ECNONTRÓ QUE TIENE CONTRAPARDITA
						// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						// REVISA SI LOS MOVIMIENTOS CUENTAN CON UN VALOR DIFERENTE EN "IN" SI ES ASÍ,
						// ES PORQUE EL
						// REVERSO NO CONTEMPLA DEVOLUCIÓN DEL GMF
						if (movimiento.getIn() != null && mov.getIn() != null
								&& !movimiento.getIn().equals(mov.getIn())) {
							this.listaDuplaMovsGMFNoReversado.add(mov); // EL QUE ESTABA EN LA LISTA
							this.listaDuplaMovsGMFNoReversado.add(movimiento); // EL QUE NO PUDO ADICIONAR A LA LISTA
						}
						// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
						listaMovimientos.remove(posLista); // REMUEVE DE LA LISTA EL MOVIMIENTO CONTRAPARTIDA
						break; // TERMINA EL CICLO
					}
				}
			}
		}
		if (puedeAddMov)
			listaMovimientos.add(movimiento);
	}

//=======================================================================================================================
	// MÉTODOS DE IR Y RETURN : REQUIEREN ESTAR LOGUEADO EN STRATUS PARA DIRECCIONAR
	// A LAS PANTALLAS:
	/**
	 * Este método ubica a Stratus en la pantalla "CONSULTA DE MAESTRAS".<br>
	 * Requerido que la consola esté abierta y se encuentre en el menú inicial.
	 */
	private void irConsultaMaestra() throws Exception {

		String msgError = this.selectOpcionMenuLista(CommonStratus.OPC_CONSULTA_CTA);
		if (msgError != null)
			throw new Exception("STRATUS ERROR -- " + msgError);
		this.read(PT_CONSULTA_MAESTRAS); // ESPERA MIENTRAS NO QUEDE LA PANTALLA EN [PT_CONSULTA_MAESTRAS]
		this.numEscapeQInicio = 1;
	}

//***********************************************************************************************************************
	/**
	 * Este método ubica a Stratus en la pantalla "CONSULTA DE PORTAFOLIO A TRAVES
	 * DEL NIT".<br>
	 * Requerido que la consola esté abierta y se encuentre en el menú inicial.
	 */
	private void irConsultaPortafolio() throws Exception {

		String msgError = this.selectOpcionMenuLista(CommonStratus.OPC_CONSULTA_PRODS);
		if (msgError != null)
			throw new Exception("STRATUS ERROR -- " + msgError);
		this.read(PT_CONSULTA_PORTAF_NIT); // ESPERA MIENTRAS NO QUEDE LA PANTALLA EN [PT_CONSULTA_PORTAF_NIT]
		this.numEscapeQInicio = 1;
	}

//***********************************************************************************************************************
	/**
	 * Este método ubica a Stratus en la pantalla "MODULO PARA RELACIONAR CUENTA DE
	 * DESTANQUEO DE CREDIPLUS".<br>
	 * Requerido que la consola esté abierta y se encuentre en el menú inicial.
	 */
	private void irParametrizacionCrediplus() throws Exception {

		String msgError = this.selectOpcionMenuLista(CommonStratus.OPC_PARAM_CREDIPLUS);
		if (msgError != null)
			throw new Exception("STRATUS ERROR -- " + msgError);
		this.read(PT_PARAMET_CREDIPLUS); // ESPERA MIENTRAS NO QUEDE LA PANTALLA EN [PT_PARAMET_CREDIPLUS]
		this.numEscapeQInicio = 1;
	}

//***********************************************************************************************************************
	/**
	 * Este método ubica a Stratus en la pantalla "BLOQUEO TRANSACCIONAL".<br>
	 * Requerido que la consola esté abierta y se encuentre en el menú inicial.
	 */
	private void irBloqueoTransaccionalxCuenta() throws Exception {

		String msgError = this.selectOpcionMenuLista(CommonStratus.OPC_BLOQ_TX_POR_CTA);
		if (msgError != null)
			throw new Exception("STRATUS ERROR -- " + msgError);
		// LA OPCIÓN 1 "ADMINISTRACION BLOQUEOS POR CUENTA" ESTÁ SELECCIONADA POR
		// DEFECTO, SE DEJA
		this.ctrlXE();
		this.read(PT_BLOQUEO_TRANSACC); // ESPERA MIENTRAS NO QUEDE LA PANTALLA EN [PT_BLOQUEO_TRANSACC]
		this.numEscapeQInicio = 2;
		// AL INGRESAR, EL CURSOR SE ENCUENTR AUBICADO EN EL CAMPO "TIPO CUENTA"
	}

//=======================================================================================================================
	// MÉTODOS DE IR Y RETURN : REQUIEREN ESTAR LOGUEADO EN STRATUS PARA DIRECCIONAR
	// A LAS PANTALLAS:
	/**
	 * Este método ubica a Stratus en la pantalla "ACTUALIZACION DALIRPR".<br>
	 * Requerido que la consola esté abierta y se encuentre en el menú inicial.
	 */
	private void irConsultaPortafolizacion() throws Exception {

		String msgError = this.selectOpcionMenuLista(CommonStratus.OPC_CONSUL_PORTAFOLIOS);
		if (msgError != null)
			throw new Exception("STRATUS ERROR -- " + msgError);
		this.read(PT_CONSULTA_PORTAFOLIOS); // ESPERA MIENTRAS NO QUEDE LA PANTALLA EN [PT_CONSULTA_PORTAFOLIOS]
		this.numEscapeQInicio = 1;
	}
//***********************************************************************************************************************
	/**
	 * Retorna al menú inicial desde la pantalla [PT_CONSULTA_PORTAF_NIT]
	 */
	/*
	 * private void returnInicio_desdeConsPortafXNIT() { switch (this.perfil) { case
	 * CommonStratus.PERFIL_CANALES: this.escapeQ(2); break; case
	 * CommonStratus.PERFIL_EMPRESAS: this.escapeQ(1); break; case
	 * CommonStratus.PERFIL_GENERICO: this.escapeQ(1); Util.wait(1); // SE DEMORA UN
	 * POCO PARA CARGAR EL MENÚ this.selectOpcionMenuLista(0); break; }
	 * Util.wait(1); // PARA QUE REFRESQUE }
	 */
//***********************************************************************************************************************
	/**
	 * Retorna al menú inicial desde la pantalla [PT_CONSULTA_MAESTRAS]
	 */

	/*
	 * private void returnInicio_desdeConsultaMaestra() { switch (this.perfil) {
	 * case CommonStratus.PERFIL_CANALES: this.escapeQ(3); break; case
	 * CommonStratus.PERFIL_EMPRESAS: this.escapeQ(1); break; case
	 * CommonStratus.PERFIL_GENERICO: this.escapeQ(2); Util.wait(1); // SE DEMORA UN
	 * POCO PARA CARGAR EL MENÚ this.selectOpcionMenuLista(0); break; }
	 * Util.wait(1); // PARA QUE REFRESQUE }
	 */
//=======================================================================================================================
	// TODO >> MÉTODOS DE CONSULTAS DE DATOS COMO SE MUESTRAN EN STRATUS:
	/**
	 * Método que retorna la línea donde vienen los errores, en Stratus.<br>
	 * Si [isGeneralError] retorna la línea del error general, de lo contrario
	 * retorna la línea de error de saldo.
	 */
	private String getLineaError(String textoPantalla, boolean isGeneralError) {

		String valRetorno = "";
		if (isGeneralError)
			valRetorno = this.getLineaErrorGeneral(textoPantalla);
		else {
			String[] lineas = textoPantalla.split("\n");
			if (lineas.length == 1) // NO CONTIENE LA PANTALLA DE STRATUS, ES SÓLO 1 MENSAJE
				valRetorno = textoPantalla;
			else
				valRetorno = Util.getTextoEntre(lineas[RENG_ERROR_SALDO], "|", "|");
		}
		return valRetorno;
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un String[] los datos presentados en la pantalla de saldo, en el
	 * orden en que se presentan:
	 * <p>
	 * <b>CTA_AHORROS</b><br>
	 * 0-Saldo total, 1-Saldo disponible, 2-Canje local, 3-Canje plaza, 4-Saldo
	 * embargado, 5-Saldo bolsillos. <br>
	 * <b>CTA_CORRIENTE</b><br>
	 * 0-Saldo Disponible, 1-Canje Local, 2-Canje plaza, 3-Disponible sobregiro,
	 * 4-Interes sobregiro causado, 5-Días en sobregiro, 6-Saldo Total, 7-Remesas
	 * negociadas, 8-Disponible remesas, 9-Saldo embargado. <br>
	 * <b>CREDITO</b><br>
	 * 0-dias mora, 1-fecha saldo (dd/mm/aaaa), 2-valor saldo, 3-fecha mora
	 * (dd/mm/aaaa), 4-valor mora, 5-fecha cuota (dd/mm/aaaa), 6-valor cuota,
	 * 7-valor cupo disponible, 8-valor pago por aplicar. <br>
	 * <b>TARJETA_CREDITO</b><br>
	 * 0-Cupo Disponible, 1-Disponible avance, 2-Pago total cartera, 3-Pago mínimo
	 * cartera, 4-Saldo cubrir mora, 5-Cuotas en mora, 6-Davipuntos vigentes, 7-
	 * Fecha corte (aaaa/mm/dd), 8-Fecha límite pago (aaaa/mm/dd), 9-Estado, 10-Pago
	 * total cartera dólares, 11-Pago Minimo Cartera Dolares <br>
	 * <b>FONDO_INVERSION</b><br>
	 * 0-Fecha de apertura (dd/mm/aaaa), 1-Saldo total, 2-Saldo disponible para
	 * cancelación, 3-Saldo disponible para retiro, 4-Saldo disponible para
	 * programar, 5-Valor en canje, 6-Fecha 1er aporte (dd/mm/aaaa), 7-Monto de
	 * apertura, 8-Cta. debito auto
	 */
	private String[] getDatosPantallaSaldos(String textoPantalla, String tipoProd) {

		int numDatos = 6; // CTA_AHORROS
		if (tipoProd.equals(CTA_CORRIENTE))
			numDatos = 10;
		else if (tipoProd.equals(CREDITO) || tipoProd.equals(FONDO_INVERSION))
			numDatos = 9;
		else if (tipoProd.equals(TARJETA_CREDITO))
			numDatos = 12;
		String[] datosSaldo = new String[numDatos];
		switch (tipoProd) {
		case CTA_AHORROS: // Fin de cada línea: Enter ("\n")
			// 0-Saldo total, 1-Saldo disponible, 2-Canje local, 3-Canje plaza, 4-Saldo
			// embargado, 5-Saldo bolsillos
			datosSaldo[0] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo Total :", "\n"), 2);
			datosSaldo[1] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo Disponible:", "\n"), 2);
			datosSaldo[2] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Canje local:", "\n"), 2);
			datosSaldo[3] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Canje plaza:", "\n"), 2);
			datosSaldo[4] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo Embargado:", "\n"), 2);
			datosSaldo[5] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo Bolsillos:", "\n"), 2);
			break;

//-----------------------------------------------------------------------------------------------------------------------
		case CTA_CORRIENTE: // Fin de cada línea: "|"
			// 0-Saldo Disponible, 1-Canje Local, 2-Canje plaza, 3-Disponible sobregiro,
			// 4-Interes sobregiro causado,
			// 5-Días en sobregiro, 6-Saldo Total, 7-Remesas negociadas, 8-Disponible
			// remesas, 9-Saldo embargado
			datosSaldo[0] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "DISPONIBLE EFECTIVO", "|"), 2);
			datosSaldo[1] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "SALDO CANJE LOCAL", "|"), 2);
			datosSaldo[2] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "SALDO CANJE PLAZA", "|"), 2);
			datosSaldo[3] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "DISPONIBLE SOBREG ", "|"), 2);
			datosSaldo[4] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "INT. SOBREG CAUSADO", "|"), 2);
			// Se requiere con espacios el texto inicial enviado a [getTextoEntre])
			datosSaldo[5] = Util.getTextoEntre(textoPantalla, "DIAS EN SOBREGIRO   ", " ");
			datosSaldo[6] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "SALDO TOTAL", "|"), 2);
			datosSaldo[7] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "REMESAS NEGOCIADAS", "|"), 2);
			datosSaldo[8] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "DISPONIBLE REMESAS", "|"), 2);
			datosSaldo[9] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "SALDO EMBARGADO", "|"), 2);
			break;

//-----------------------------------------------------------------------------------------------------------------------
		// 0-dias mora, 1-fecha saldo (dd/mm/aaaa), 2-valor saldo, 3-fecha mora
		// (dd/mm/aaaa), 4-valor mora,
		// 5-fecha cuota (dd/mm/aaaa), 6-valor cuota, 7-valor cupo disponible, 8-valor
		// pago por aplicar
		case CREDITO: // Fin de cada línea: Enter ("\n")
			datosSaldo[0] = Util.getTextoEntre(textoPantalla, "Dias mora:", "\n");
			// Información de Saldo:
			String[] arrayTemp = this.cargarFechaValor(textoPantalla, "Saldo:", "\n");
			datosSaldo[1] = arrayTemp[0];
			datosSaldo[2] = arrayTemp[1];
			// Información de Mora: Se requiere con espacios para que no se confunda con
			// "Dias mora:"
			arrayTemp = this.cargarFechaValor(textoPantalla, "   Mora:", "\n"); //
			datosSaldo[3] = arrayTemp[0];
			datosSaldo[4] = arrayTemp[1];
			// Información de Cuota:
			arrayTemp = this.cargarFechaValor(textoPantalla, "Cuota:", "\n");
			datosSaldo[5] = arrayTemp[0];
			datosSaldo[6] = arrayTemp[1];
			datosSaldo[7] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Cupo disponible :", "\n"), 2);
			datosSaldo[8] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Pago por aplicar:", "\n"), 2);
			break;

//-----------------------------------------------------------------------------------------------------------------------
		// 0-Cupo Disponible, 1-Disponible avance, 2-Pago total cartera, 3-Pago mínimo
		// cartera, 4-Saldo cubrir mora,
		// 5-Cuotas en mora, 6-Davipuntos vigentes, 7- Fecha corte (aaaa/mm/dd), 8-Fecha
		// límite pago (aaaa/mm/dd),
		// 9-Estado, 10-Pago total cartera dólares, 11-Pago Minimo Cartera Dolares
		case TARJETA_CREDITO: // Fin de cada línea: "|"
			datosSaldo[0] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Cupo Disponible:", "|"), 2);
			datosSaldo[1] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Disponible Avance:", "|"), 2);
			datosSaldo[2] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Pago Total Cartera Pesos:", "|"),
					2);
			datosSaldo[3] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Pago Minimo Cartera Pesos:", "|"),
					2);
			datosSaldo[4] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo Para Cubrir Mora:", "|"), 2);
			datosSaldo[5] = Util.getTextoEntre(textoPantalla, "Cuotas en Mora:", "|");
			datosSaldo[6] = Util.getTextoEntre(textoPantalla, "Davipuntos Vigentes:", "|");
			datosSaldo[7] = Util.getTextoEntre(textoPantalla, "Fecha de Corte:", "|");
			datosSaldo[8] = Util.getTextoEntre(textoPantalla, "Fecha Limite Pago:", "|");
			datosSaldo[9] = Util.getTextoEntre(textoPantalla, "Estado:", "|");
			String pagoTotalCarteraUSDPesos = "0.00";
			String label = "Pago Total Cartera Dolares en Pesos:";
			if (textoPantalla.contains(label))
				pagoTotalCarteraUSDPesos = Util.toNumberInString(Util.getTextoEntre(textoPantalla, label, "|"), 2);
			datosSaldo[10] = pagoTotalCarteraUSDPesos;
			String pagoMinCarteraUSDPesos = "0.00";
			label = "Pago Minimo Cartera Dolares en Pesos:";
			if (textoPantalla.contains(label))
				pagoTotalCarteraUSDPesos = Util.toNumberInString(Util.getTextoEntre(textoPantalla, label, "|"), 2);
			datosSaldo[11] = pagoMinCarteraUSDPesos;
			break;

//-----------------------------------------------------------------------------------------------------------------------
		// 0-Fecha de apertura (dd/mm/aaaa), 1-Saldo total, 2-Saldo disponible para
		// cancelación,
		// 3-Saldo disponible para retiro, 4-Saldo disponible para programar, 5-Valor en
		// canje,
		// 6-Fecha 1er aporte (dd/mm/aaaa), 7-Monto de apertura, 8-Cta. debito auto
		case FONDO_INVERSION:
			// TRANSFORMA LA INFORMACIÓN PARA EXTRAER LA FECHA DE APERTURA:
			final int RENGLON_FECHA = 4; // Empieza en cero 0
			final int COLUMNA_CTA_DEB_AUTOM = 1; // Empieza en cero 0
			final int COLUMNA_FECHA_APORTE1 = 2; // Empieza en cero 0
			final int COLUMNA_FECHA_APERTURA = 3; // Empieza en cero 0
			// El texto de la pantalla lo parte por Enter
			String[] arrayLineas = textoPantalla.split("\n");
			// Los datos requeridos están en la posición RENGLON_FECHA, limpia los dobles
			// espacios de esa línea y la divide por espacios
			String[] arrayDatos = Util.totalTrim(arrayLineas[RENGLON_FECHA]).split(" ");
			// LAS FECHAS VIENEN EN FORMATO aaaa/mm/dd, SE DIVIDE POR "/" PARA EXTRAER LOS
			// DATOS
			// La fecha de apertura es la existente en la posición COLUMNA_FECHA_APERTURA
			String[] arrayFecha = arrayDatos[COLUMNA_FECHA_APERTURA].split("/");
			datosSaldo[0] = arrayFecha[2] + "/" + arrayFecha[1] + "/" + arrayFecha[0];
			datosSaldo[1] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Saldo total", "Vlr contingen"), 2);
			datosSaldo[2] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Disp. cancel", "Fec Vencimiento"),
					2);
			datosSaldo[3] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Disp  retiro", "Cta para retiro"),
					2);
			datosSaldo[4] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Disp programar", "\n"), 2);
			datosSaldo[5] = Util.toNumberInString(Util.getTextoEntre(textoPantalla, "Vlr en canje", "Disp programar"),
					2);
			// La fecha del 1er aporte es la existente en la posición COLUMNA_FECHA_APORTE1
			arrayFecha = arrayDatos[COLUMNA_FECHA_APORTE1].split("/");
			datosSaldo[6] = arrayFecha[2] + "/" + arrayFecha[1] + "/" + arrayFecha[0];
			// "Monto de apertura" y "Cta. debito auto" están en la misma línea
			// [RENGLON_FECHA]
			datosSaldo[7] = Util.toNumberInString(Util.getTextoEntre(arrayLineas[RENGLON_FECHA], " $", "\n"));
			datosSaldo[8] = arrayDatos[COLUMNA_CTA_DEB_AUTOM];
			break;
		}
		return datosSaldo;
	}

//***********************************************************************************************************************
	/**
	 * Este método retorna en un array de 2 elementos, la infornmación de fecha y
	 * valor que se encuentra en el texto [textoPantalla] entre [textoInicio] y
	 * [textoFin], estos dos valores deben venir en una sola línea.<br>
	 * El texto que posiblemnete no viene es el de la fecha, si no viene se pone "".
	 * 
	 * @return - pos0=fecha (en formato dd/mm/aaaa), pos1=Valor
	 */
	private String[] cargarFechaValor(String textoPantalla, String textoInicio, String textoFin) {

		String[] fechaValor = new String[2];
		// LIMPIA LA LÍNEA QUITANDO LOS DOBLES ESPACIOS INTERNOS, Y SIN ESPACIO AL
		// INICIO NI AL FINAL
		String textoTemp = Util.totalTrim(Util.getTextoEntre(textoPantalla, textoInicio, textoFin));
		String[] arrayTemp = textoTemp.split(" ");
		if (arrayTemp.length == 2) {
			// arrayTemp[0] viene en formato aaaammdd y se debe transformar a dd/mm/aaaa
			fechaValor[0] = arrayTemp[0].substring(6, 8) + "/" + arrayTemp[0].substring(4, 6) + "/"
					+ arrayTemp[0].substring(0, 4);
			fechaValor[1] = Util.toNumberInString(arrayTemp[1], 2);
		} else {
			fechaValor[0] = "";
			fechaValor[1] = Util.toNumberInString(arrayTemp[0], 2);
		}
		return fechaValor;
	}

//=======================================================================================================================
	// TODO >> MÉTODOS ESTÁTICOS DE STRATUS
	/**
	 * Retorna el valor del tipo de cuenta como se presenta en Stratus para hacer
	 * consultas de la cuenta, ya sea en "C O N S U L T A D E M A E S T R A S" o en
	 * otras pantallas.
	 */
	public static String getTipoCuenta(String tipoCuenta) {

		String tipoCta = Util.removeAccents(tipoCuenta.trim()).toUpperCase();
		String valRetorno = "";
		if (tipoCta.contains("AHORRO") || tipoCta.equals("CA") || tipoCta.equals("AH")
				|| tipoCta.equals(MOV_CTA_AHORROSDM) || tipoCta.equals(MOV_CTA_AHORROSFD))
			valRetorno = CTA_AHORROS;
		else if (tipoCta.contains("CORRIENTE") || tipoCta.equals("CC") || tipoCta.equals(MOV_CTA_CORRIENTE)
				|| tipoCta.equals("CREDIPLUS"))
			valRetorno = CTA_CORRIENTE;
		else if (tipoCta.contains("TARJETA") || tipoCta.equals("TC"))
			valRetorno = TARJETA_CREDITO;
		else if (tipoCta.contains("CREDITO") || tipoCta.contains("CREDI") || tipoCta.equals(CREDITO))
			valRetorno = CREDITO;
		else if (tipoCta.contains("FONDO"))
			valRetorno = FONDO_INVERSION;
		else if (Util.itemInArray(tipoCta, ARR_PROD_MOVS))
			valRetorno = tipoCta;
		return valRetorno;
	}

//***********************************************************************************************************************
	/**
	 * Este método retorna el valor del tipo de documento como se presenta en
	 * Stratus, para la consulta en CONSULTA DE PORTAFOLIO A TRAVES DEL NIT
	 */
	private static String getTipoDocumentoConsPortafolio(String tipoDocumento) {

		String tipoDoc = Util.removeAccents(tipoDocumento.toUpperCase().trim());
		String valRetorno = "";
		if (tipoDoc.contains("CIUDADANÍA") || tipoDoc.contains("CIUDADANIA") || tipoDoc.contains("CC"))
			valRetorno = "Cedula ciudadania";
		else if ((tipoDoc.contains("CEDULA") && tipoDoc.contains("EXTRANJERIA")) || tipoDoc.contains("CE"))
			valRetorno = "Cedula extranjeria";
		else if (tipoDoc.equals("NIT"))
			valRetorno = "NIT";
		else if (tipoDoc.contains("IDENTIDAD") || tipoDoc.contains("TI"))
			valRetorno = "Tarjeta identidad";
		else if (tipoDoc.contains("PASAPORTE"))
			valRetorno = "Pasaporte";
		else if ((tipoDoc.contains("TARJETA") && tipoDoc.contains("SOCIAL")) || tipoDoc.contains("TS"))
			valRetorno = "Tarjeta social ext";
		else if ((tipoDoc.contains("SOCIEDAD") && tipoDoc.contains("EXTRANJERA")) || tipoDoc.contains("SE"))
			valRetorno = "Sociedad Extranjera";
		else if (tipoDoc.contains("FIDEICOMISO") || tipoDoc.contains("F"))
			valRetorno = "Fideicomiso";
		else if (tipoDoc.contains("MENORES") || tipoDoc.contains("NM"))
			valRetorno = "Nit menores";
		else if (tipoDoc.contains("RIF") || tipoDoc.contains("RV"))
			valRetorno = "Rif Venezuela";
		else if ((tipoDoc.contains("NIT") && tipoDoc.contains("EXTRANJERIA")) || tipoDoc.contains("NE"))
			valRetorno = "Nit Extranjeria";
		else if ((tipoDoc.contains("NIT") && tipoDoc.contains("PERSONA")) || tipoDoc.contains("NPN"))
			valRetorno = "Nit Persona Natura";
		else if (tipoDoc.contains("CIVIL") || tipoDoc.contains("RC"))
			valRetorno = "Registro Civil Nac";
		else if (tipoDoc.equals("NUIP"))
			valRetorno = "NUIP";
		else if ((tipoDoc.contains("NIT") && tipoDoc.contains("DESASOCIADO")) || tipoDoc.contains("ND"))
			valRetorno = "Nit Desasociado";
		return valRetorno;
	}

//***********************************************************************************************************************
	/**
	 * Este método indica si el número de producto encontrado en Stratus
	 * [numProdStr] corresponde al producto que se busca, del cual se conoce su tipo
	 * [tipoProducto] y la parte del número con el que se compara [numProd]. Esta
	 * búsqueda es útil cuando se hacen búsquedas en [PT_CONSULTA_PORTAF_NIT]
	 */
	private static boolean isProductoBuscado(String tipoProducto, String numProd, String numProdStr) {

		if (numProd.length() == TAM_NUM_CTA && numProdStr.equals(numProd))
			return true;
//-----------------------------------------------------------------------------------------------------------------------
		// EN TODOS LOS CASOS VALIDA QUE LOS 4 ÚLTIMOS DÍGITOS DEL PRODUCTO STRATUS
		// [numProdStr] = numProd
		// MENOS PARA [CREDITO_COBROS_PORTAF]
		boolean isProducto = false;
		if (tipoProducto.equals(CTA_CORRIENTE)) // INICIO = 056 / 000000
			isProducto = (Util.right(numProdStr, 4).equals(numProd)
					&& (Util.left(numProdStr, 3).equals("056") || Util.left(numProdStr, 6).equals("000000")));
		else if (tipoProducto.equals(CTA_AHORROS)) // INICIO = 055 / 057 / 000000
			isProducto = (Util.right(numProdStr, 4).equals(numProd) && (Util.left(numProdStr, 3).equals("055")
					|| Util.left(numProdStr, 3).equals("057") || Util.left(numProdStr, 6).equals("000000")));
		else if (tipoProducto.equals(FONDO_INVERSION)) // BUSCA EL NÚMERO DE PRODUCTO COMPLETO
			isProducto = numProdStr.equals(numProd);
		else if (tipoProducto.equals(CREDITO)) { // INICIO = 6 / 7 / 059 / 0000
			String inic = Util.left(numProdStr, 1);
			String[] arrInici = { "6", "7" };
			isProducto = (Util.right(numProdStr, 4).equals(numProd) && (Util.itemInArray(inic, arrInici)
					|| numProdStr.startsWith("059") || numProdStr.startsWith("0000")));
		} else if (tipoProducto.equals(CREDITO_COBROS_PORTAF)) // BUSCA LOS PIRMEROS 15 DÍGITOS DEL NÚMERO DEL PRODUCTO
			isProducto = Util.left(numProdStr, 15).equals(numProd);
		else if (tipoProducto.equals(TARJETA_CREDITO)) { // INICIO = 2 / 4 / 5 / 003
			String inic = Util.left(numProdStr, 1);
			String[] arrInici = { "2", "4", "5" };
			isProducto = (Util.right(numProdStr, 4).equals(numProd)
					&& (Util.itemInArray(inic, arrInici) || Util.left(numProdStr, 3).equals("003")));
		}
		return isProducto;
	}

//***********************************************************************************************************************
	/**
	 * Indica si el número de la cuenta "numeroCta" corresponde a un número para
	 * cuenta migrada.
	 */
	public static boolean esCuentaMigrada(String numeroCta) {

		String numCta = numeroCta;
		if (numeroCta.length() != TAM_NUM_CTA)
			numCta = Util.leftComplete(numeroCta, TAM_NUM_CTA, '0');
		// MIGRADA BANCAFE : 9 DÍGITOS INICIA EN 0 : 0######## - COMPLETO SERÍA
		// 00000000########
		// MIGRADA BANSUPERIOR : 10 DÍGITOS INICIA EN 1 : 1######### - COMPLETO SERÍA
		// 0000001#########
		// "00000000" ES MIGARADA BANCAFE // "0000001" ES MIGARADA BANSUPERIOR
		return (Util.left(numCta, 7).equals("0000000") || Util.left(numCta, 7).equals("0000001"));
	}
	
	//***********************************************************************************************************************
		/**
		 * Retorna el nombre de la cuenta migrada, si es bancafa o bansuperior.
		 */
		public String getNombreCuentaMigrada(String numeroCta) {

			String numCta = numeroCta;
			if (numeroCta.length() != TAM_NUM_CTA)
				numCta = Util.leftComplete(numeroCta, TAM_NUM_CTA, '0');
			// MIGRADA BANCAFE : 9 DÍGITOS INICIA EN 0 : 0######## - COMPLETO SERÍA
			// 00000000########
			// MIGRADA BANSUPERIOR : 10 DÍGITOS INICIA EN 1 : 1######### - COMPLETO SERÍA
			// 0000001#########
			// "00000000" ES MIGARADA BANCAFE // "0000001" ES MIGARADA BANSUPERIOR
			return Util.left(numCta, 7).equals("0000000") ? "Cuenta Migrada Bancafe" : "Cuenta Migrada Bansuperior";
		}
	
	

//***********************************************************************************************************************
	/**
	 * Retorna el número de la cuenta asociada, a una cuenta migrada.<br>
	 * No puede ser método estático, ya que requiere la consulta en Stratus, si no
	 * se encuentra en [dicCtasAsoc_Migradas]
	 */
	public String getCtaAsociadaAMigrada(String tipoCta, String numeroCta) throws Exception {

		String numCta = (numeroCta.length() == TAM_NUM_CTA) ? numeroCta
				: Util.leftComplete(numeroCta, TAM_NUM_CTA, '0');
		String tipoCuenta = StratusProductos.getTipoCuenta(tipoCta); // GARANTIZA EL DATO
		String keyDic = tipoCuenta + "-" + numCta;
		if (!dicCtasAsoc_Migradas.containsKey(keyDic)) {
			String[] datos = this.getDatosCuenta(tipoCta, numCta, false, "DATOS PERSONALES DEL PRODUCTO");
			dicCtasAsoc_Migradas.put(keyDic, datos[0]);
		}
		return dicCtasAsoc_Migradas.get(keyDic);
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un arreglo, TODAS las combinaciones "mmdd hhmm " (mesdia espacio
	 * horaminuto espacio) como se presenta en la consulta de Movimientos de
	 * Stratus, desde la [fechaHoraTx] hasta los minutos indicados.
	 * 
	 * @param fechaHoraTx - Date que almacena la fecha y hora en que se realizó una
	 *                    transacción.
	 * @param minutos     - Número de los minutos hasta que se hace la búsqueda.
	 * @return String[] por ejemplo : {"0930 1009 ", "0930 1010 ", "0930 1011 ",
	 *         "0930 1012 "}
	 */
	public static String[] getArrayAll_FsiHoraMov(Date fechaHoraTx, int minutos) {

		String[] datosFH = new String[minutos + 1];
		Calendar datoAct = Calendar.getInstance();
		datoAct.setTime(fechaHoraTx);
		String fechaBuscar, horaBuscar;
		int posArr = 0;
		do {
			fechaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.MONTH) + 1), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.DATE)), 2, '0'); // MMDD
			horaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.HOUR_OF_DAY)), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.MINUTE)), 2, '0'); // HHMM
			datosFH[posArr++] = fechaBuscar + " " + horaBuscar + " ";
			datoAct.add(Calendar.MINUTE, 1);
		} while (posArr <= minutos);
		return datosFH;
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un arreglo, TODAS las combinaciones "mmdd" (mesdia) como se
	 * presenta en la consulta de Movimientos de Stratus, desde la [fechaInicial]
	 * hasta la [fechaFinal].
	 * 
	 * @param fechaInicial - Date que almacena la fecha inicial
	 * @param fechaFinal   - Date que almacena la fecha final
	 * @return String[] por ejemplo : {"0930", "1001", "1002", "1003"}
	 */
	public static String[] getArrayAll_FsiMov(Date fechaInicial, Date fechaFinal) {

		int difDias = (int) TimeUnit.MILLISECONDS.toDays(fechaFinal.getTime() - fechaInicial.getTime());
		String[] datosFecha = new String[difDias + 1];
		Calendar datoAct = Calendar.getInstance();
		datoAct.setTime(fechaInicial);
		String fechaBuscar;
		for (int day = 0; day <= difDias; day++) {
			fechaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.MONTH) + 1), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.DATE)), 2, '0'); // MMDD
			datosFecha[day] = fechaBuscar;
			datoAct.add(Calendar.DATE, 1);
		}
		return datosFecha;
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un arreglo, las 2 combinaciones "mmdd hhmm " (mesdia espacio
	 * horaminuto espacio) como se presenta en la consulta de Movimientos de
	 * Stratus, del dato inicial y final, desde la [fechaHoraTx] hasta los minutos
	 * indicados.
	 * 
	 * @param fechaHoraTx - Date que almacena la fecha y hora en que se realizó una
	 *                    transacción.
	 * @param minutos     - Número de los minutos hasta que se hace la búsqueda.
	 * @return String[] de 2 posiciones, por ejemplo : {"0930 1009 ", "0930 1012 "}
	 */
	public static String[] getInicFin_FsiMov(Date fechaHoraTx, int minutos) {

		String[] datosFH = new String[2];
		Calendar datoAct = Calendar.getInstance();
		datoAct.setTime(fechaHoraTx);
		String fechaBuscar, horaBuscar;
		int posArr = 0;
		do {
			fechaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.MONTH) + 1), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.DATE)), 2, '0'); // MMDD
			horaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.HOUR_OF_DAY)), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.MINUTE)), 2, '0'); // HHMM
			datosFH[posArr++] = fechaBuscar + " " + horaBuscar + " ";
			datoAct.add(Calendar.MINUTE, minutos);
		} while (posArr < 2);
		return datosFH;
	}

//***********************************************************************************************************************
	/**
	 * Retorna en un arreglo, las 2 combinaciones "mmdd hhmm " (mesdia espacio
	 * horaminuto espacio) como se presenta en la consulta de Movimientos de
	 * Stratus, del dato inicial y final, para la [fechaInicial] hasta [fechaFinal].
	 * 
	 * @param fechaInicial - Date que almacena la fecha y hora inicial.
	 * @param fechaFinal   - Date que almacena la fecha y hora final.
	 * @return String[] de 2 posiciones, por ejemplo : {"0930 1009 ", "0930 1012 "}
	 */
	public static String[] getInicFin_FsiMov(Date fechaInicial, Date fechaFinal) {

		String[] datosFH = new String[2];
		Calendar datoAct = Calendar.getInstance();
		datoAct.setTime(fechaInicial);
		String fechaBuscar, horaBuscar;
		int posArr = 0;
		do {
			fechaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.MONTH) + 1), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.DATE)), 2, '0'); // MMDD
			horaBuscar = Util.leftComplete(String.valueOf(datoAct.get(Calendar.HOUR_OF_DAY)), 2, '0')
					+ Util.leftComplete(String.valueOf(datoAct.get(Calendar.MINUTE)), 2, '0'); // HHMM
			datosFH[posArr++] = fechaBuscar + " " + horaBuscar + " ";
			datoAct.setTime(fechaFinal);
		} while (posArr < 2);
		return datosFH;
	}

//***********************************************************************************************************************
	/**
	 * Retorna el tipo de un producto, dado su número.<br>
	 * El retorno es el texto "AHORROS" / "CORRIENTE"
	 */
	public static String getTipoProductoByNumProducto(String numProducto) {

		String prefijo = getPrefijoCuenta(numProducto);
		String tipoProd = "PENDIENTE"; // VALOR POR DEFECTO
		if (prefijo.equals("0550") || prefijo.equals("0570"))
			tipoProd = "AHORROS";
		else if (prefijo.equals("0560"))
			tipoProd = "CORRIENTE";
		return tipoProd;
	}

//***********************************************************************************************************************
	/**
	 * Retorna el sufijo de la cuenta "AHORROS" / "CORRIENTE" que se recibe en
	 * [numCuenta].<br>
	 * A 12 dígitos mirando el 5to dígito: 0 / 5 = DAMAS (0550), 6 = CORRIENTE
	 * (0560), 7 / 8 = FIJO DIARIO (0570)
	 * 
	 * @param numCuenta - La cuenta está a 12 dígitos, si no lo está se quitan los
	 *                  dígitos de la izquierad sobrantes.
	 * @return posibles valores "0550" / "0560" / "0570"
	 */
	public static String getPrefijoCuenta(String numCuenta) {

		String numCtaEval = numCuenta.length() == TAM_NUM_CTA ? numCuenta
				: Util.leftComplete(numCuenta, TAM_NUM_CTA, '0');
		if (cuentaTienePrefijo(numCtaEval)) // YA TIENE EL PREFIJO SE RETORNA
			return Util.left(numCtaEval, 4);
//-----------------------------------------------------------------------------------------------------------------------		
		// DEJA EL NÚMERO DE LA CUENTA A 12 DÍGITOS PARA DETERMINAR EL PREFIJO
		numCtaEval = Util.right(numCtaEval, 12);
		String sufijo = "0000"; // VALOR POR DEFECTO
		if (!esCuentaMigrada(numCtaEval)) { // PARA LAS CUENTAS MIGRADAS, NO SE SABE EL PREFIJO, TOCA CON EL ALIAS
			int idtipoCta = Integer.valueOf(Util.mid(numCtaEval, 5, 1));
			if (idtipoCta == 0 || idtipoCta == 5) // DAMAS
				sufijo = "0550";
			else if (idtipoCta == 6) // CORRIENTE
				sufijo = "0560";
			else if (idtipoCta == 7 || idtipoCta == 8) // FIJO DIARIO
				sufijo = "0570";
		}
		return sufijo;
	}

//***********************************************************************************************************************
	/**
	 * Retorna el tipo de la cuenta según la información del número de la cuenta
	 * 
	 * @return Valores a retornar: DM, FD, CC o N/A en caso que la cuenta no cuente
	 *         con el prefijo respectivo.
	 */
	public static String getTipoCta_DMFDCC(String numCuenta) {

		String tipoProd = "N/A"; // NO ESTÁ DEFINIDA, SE DEBE REVISAR
		String prefijo = StratusProductos.getPrefijoCuenta(numCuenta);
		if (prefijo.equals("0550"))
			tipoProd = "DM"; // CUENTA DE AHORROS DAMAS
		else if (prefijo.equals("0560"))
			tipoProd = "CC"; // CUENTA CORRIENTE
		else if (prefijo.equals("0570"))
			tipoProd = "FD"; // CUENTA DE AHORROS FIJO DIARIO
		return tipoProd;
	}

//***********************************************************************************************************************
	/**
	 * Retorna el número de la cuenta [numeroCta] con el total de dígitos requerido
	 * para hacer la consulta en CONSULTA DE MAESTRAS. Incluyendo el prefijo de la
	 * cuenta, cuando no se cuenta con el prefijo aveces no se puede hacer la
	 * correcta consulta de saldos y movimientos.
	 * 
	 * @return [numeroCta] a 16 dígitos con el prefijo respectivo
	 */
	public static String getNumCtaParaConsultaMaestra(String numeroCta) {

		// COMPLETA LA LONGITUD DEL NÚMERO DE LA CUENTA AL NÚMERO DE DÍGITOS INDICADO POR [TAM_NUM_CTA]
		String numCta = (numeroCta.length() == TAM_NUM_CTA) ? numeroCta
				: Util.leftComplete(numeroCta, TAM_NUM_CTA, '0');
		// SE PUEDE CALCULAR SI NO ES UNA CUENTA MIGRADA
		if (Util.left(numCta, 2).equals("00") && !esCuentaMigrada(numCta)) {
			String prefijo = getPrefijoCuenta(numCta);
			numCta = prefijo + Util.right(numCta, 12);
		}
		return numCta;
	}

//***********************************************************************************************************************
	private static String[] ARR_PREFIJOS = { "0550", "0560", "0570" };

	/**
	 * Indica si [numCuenta] empieza con el prefijo de los números de cuenta de
	 * ahorro o corriente.<br>
	 */
	private static boolean cuentaTienePrefijo(String numCuenta) {

		String numCtaEval = numCuenta.length() == TAM_NUM_CTA ? numCuenta
				: Util.leftComplete(numCuenta, TAM_NUM_CTA, '0');
		String prefijo = Util.left(numCtaEval, 4);
		return Util.itemInArray(prefijo, ARR_PREFIJOS);
	}

//***********************************************************************************************************************	
	/**
	 * Método para consultar la tarjeta de crédito. Pre-Requisito (Login de Stratus)
	 * Proceso - 1 Banca Empresarial - 4 Consulta saldos - diligencia el @param
	 * numDocumento - Busca la tarjeta indicada en el @param numeroTarjeta pantalla
	 * final (Consulta tarjeta Credito)
	 * 
	 * @author JFQUINON (Jhon Quiñones Arboleda)
	 * @param numDocumento  El número de documento del titular de la tarjeta.
	 * @param numeroTarjeta El número de la tarjeta de crédito a consultar.
	 * @return La tarjeta de crédito consultada.
	 */
	public String consultaTarjetaCredito(String numDocumento, String numeroTarjeta) {
		String tarjetaActual = null;
		this.selectOpcionMenuLista(1);
		// Util.wait(2);
		// this.selectOpcionMenuLista(4);
		Util.wait(2);
		this.write(numDocumento);
		this.enter(2);
		Util.wait(2);

		boolean tarjetaEncontrada = false;
		int intentos = 0;
		int numeroLinea = 0; // Variable para el número de línea
		int posicionTarjeta = 0; // posición de la tarjeta
		// Bucle para buscar la tarjeta indicada
		while (!tarjetaEncontrada && intentos < 10) { // Límite de intentos para evitar bucles infinitos
			Util.wait(1); // Esperar un segundo entre tabs
			// Leer la pantalla completa
			String pantallaInicial = this.read();
			String pantallaCompleta = Util.getTextoEntre(pantallaInicial, "Cedula ciudadania", "F1");
			// Dividir la pantalla en líneas
			String[] lineas = pantallaCompleta.split("\n");
			// Buscar el número de tarjeta en cada línea
			for (String linea : lineas) {
				numeroLinea++; // Incrementar el número de línea
				// Dividir la línea en tarjetas individuales
				String[] tarjetas = linea.trim().split("\\s+"); // Dividir por espacios en blanco
				// Verificar si la línea contiene la tarjeta buscada
				for (int i = 0; i < tarjetas.length; i++) {
					if (tarjetas[i].equals(numeroTarjeta)) {
						tarjetaActual = tarjetas[i];
						tarjetaEncontrada = true;
						posicionTarjeta = i;
						break; // Salir del bucle interno si se encuentra la tarjeta
					}
				}

				if (tarjetaEncontrada) {
					break; // Salir del bucle externo si se encuentra la tarjeta
				}
			}
			intentos++; // Incrementar el contador de intentos
		}
		// Verificar si se encontró la tarjeta y ejecutar acción correspondiente

		int lineareal = (numeroLinea - 4);

		// Calcular incremental dinámicamente
		int incremental = (lineareal / 2) * 3; // Divide lineareal entre 2 y multiplica por 3

		// Reportar el valor de lineareal
		Reporter.write("LINEA DE LA TARJETA ES: " + lineareal);

		if (tarjetaEncontrada) {
			this.tab((posicionTarjeta + incremental) - 1);
			this.seleccionarTarjetaCtrolX();
		} else {
			return "NO SE ENCUENTRA LA TARJETA INDICADA";
		}

		return tarjetaActual;
	}

//***********************************************************************************************************************	
	/* @author JFQUINON (Jhon Quiñones Arboleda) */
	private void seleccionarTarjetaCtrolX() {

		this.saveEvidence("Tarjeta seleccionada");
		this.ctrlX(1); // Presionar Ctrl + X para seleccionar la tarjeta indicada
		Util.wait(2);
		this.saveEvidence("Infomación Tarjeta seleccionada");
	}

//***********************************************************************************************************************	
	/**
	 * Método para extraer los datos relevantes de la consulta de crédito.
	 * 
	 * @author JFQUINON (Jhon Quiñones Arboleda)
	 * @return Una cadena de texto con los datos relevantes de la consulta de
	 *         crédito.
	 */
	public String extraerDatosConsultaCredito() {

		String pantalla = this.read(); // Leer la pantalla de la consulta de crédito
		// Extraer los datos principales
		String cupoDisponible = Util.getTextoEntre(pantalla, "Cupo Disponible:", " |\n").trim();
		String disponibleAvance = Util.getTextoEntre(pantalla, "Disponible Avance:", " |\n").trim();
		String pagoTotalCartera = Util.getTextoEntre(pantalla, "Pago Total Cartera Pesos:", " |\n").trim();
		String pagoMinimoCartera = Util.getTextoEntre(pantalla, "Pago Minimo Cartera Pesos:", " |\n").trim();
		String cuotasMora = Util.getTextoEntre(pantalla, "Cuotas en Mora:", " |\n").trim();
		String estado = Util.getTextoEntre(pantalla, "Estado:", "\n").trim();
		String fechaCorte = Util.getTextoEntre(pantalla, "Fecha de Corte:", " |\n").trim();
		String fechaLimitePago = Util.getTextoEntre(pantalla, "Fecha Limite Pago:", " |\n").trim();
		String fechaVencimientoTarjeta = Util.getTextoEntre(pantalla, "Fecha Vencimiento Tarjeta:", " |\n").trim();
		// Construir el resultado
		StringBuilder datosRelevantes = new StringBuilder();
		datosRelevantes.append("Cupo Disponible: ").append(cupoDisponible).append("\n");
		datosRelevantes.append("Disponible Avance: ").append(disponibleAvance).append("\n");
		datosRelevantes.append("Pago Total Cartera Pesos: ").append(pagoTotalCartera).append("\n");
		datosRelevantes.append("Pago Minimo Cartera Pesos: ").append(pagoMinimoCartera).append("\n");
		datosRelevantes.append("Cuotas en Mora: ").append(cuotasMora).append("\n");
		datosRelevantes.append("Estado: ").append(estado).append("\n");
		datosRelevantes.append("Fecha de Corte: ").append(fechaCorte).append("\n");
		datosRelevantes.append("Fecha Limite Pago: ").append(fechaLimitePago).append("\n");
		datosRelevantes.append("Fecha Vencimiento Tarjeta: ").append(fechaVencimientoTarjeta).append("\n");
		return datosRelevantes.toString().replace("|", "");
	}

//***********************************************************************************************************************	
	/**
	 * Metodo encargado de realizar generación de evidencias en Stratus en opción 67
	 */
	public String opcion67Stratus(String numTarjeta, String cuenta, String numAuditoria, String valorTransaccion) {
		int tamanotexto = 3336;
		int renglonIni = 0;
		int renglonFinal = 24; // Valor predeterminado si no se encuentran coincidencias

		Util.wait(1);
		this.selectOpcionMenuLista(67);
		this.write(numTarjeta);
		Util.wait(1);
		this.enter();
		String textopantalla = this.read();
		Util.wait(2);

		// Búsqueda de coincidencias exactas en orden consecutivo y consecutivas
		int lineaTarjeta = -1;
		int lineaAuditoriaValorTransaccion = -1;
		int lineaCuenta = -1;

		String[] lineas = textopantalla.split("\n");
		for (int i = 0; i < lineas.length; i++) {
			if (lineas[i].contains(numTarjeta.trim()) && lineaTarjeta == -1) {
				lineaTarjeta = i;
			}
			if (lineaTarjeta != -1 && lineas[i].contains(numAuditoria.trim())
					&& lineas[i].contains(valorTransaccion.trim()) && lineaAuditoriaValorTransaccion == -1) {
				lineaAuditoriaValorTransaccion = i;
			}
			if (lineaAuditoriaValorTransaccion != -1 && lineas[i].contains(cuenta.trim()) && lineaCuenta == -1) {
				lineaCuenta = i;
				break; // Encontradas todas las líneas en orden correcto y consecutivas
			}
		}

		if (lineaTarjeta != -1 && lineaAuditoriaValorTransaccion != -1 && lineaCuenta != -1) {
			// Determinar el renglón inicial y final basándose en las coincidencias exactas
			// encontradas en orden consecutivo
			renglonIni = lineaTarjeta;
			renglonFinal = lineaCuenta + 1;
		}

		// Validar los valores de renglonIni y renglonFinal
		if (renglonIni < 0 || renglonIni > lineas.length - 1) {
			renglonIni = 0;
		}

		if (renglonFinal < 0 || renglonFinal > lineas.length || renglonFinal < renglonIni) {
			renglonFinal = lineas.length;
		}

		this.tomarEvidencia(renglonIni, renglonFinal);

		int tamano = textopantalla.length();
		if (tamano > tamanotexto) {
			this.maximizeWindow();
			this.pageDown(2);
			this.tomarEvidencia(renglonIni, renglonFinal);
		} else if (tamano > (tamanotexto * 2)) {
			this.maximizeWindow();
			this.pageDown(2);
			this.tomarEvidencia(renglonIni, renglonFinal);
		}
		return textopantalla;
	}

	private void tomarEvidencia(int renglonIni, int renglonFinal) {
		Util.wait(1);
		String evidencia = Evidence.save("TRANSACCION STRATUS", this);
		StratusBase.cortarStratusEvidenceTwo(evidencia, renglonIni, renglonFinal);
	}

//***********************************************************************************************************************	
	/**
	 * Metodo que permite ingresar a la Consulta de
	 * Portafolizacion/Desportafilizacion,<br>
	 * solicita el número de documento y los 16 digitos del número del credito.<br>
	 * 
	 * @param numDocumento
	 * @param numCredito
	 * @return Null o mensaje de error.
	 * @throws Exception
	 * @author ppavegas.
	 */
	public String consultaPortafolios(String numDocumento, String numCredito) throws Exception {

		// SE VALIDA QUE LOS DATOS NO ESTEN VACIOS.
		if (numDocumento.isEmpty() && numCredito.isEmpty())
			return "Los datos están incompletos.";
//-----------------------------------------------------------------------------------------------------------------------
		this.openStratus(); // EN CASO QUE NO ESTÉ ABIERTO STRATUS LO ABRE, SI ESTÁ ABIERTO: LO ACTIVA
		this.irConsultaPortafolizacion(); // INGRESA A LA CONSULTA CON CODIGO NUMERO 23
		this.write(numDocumento);
		Util.wait(2);
		this.tab(4);
		this.write(numCredito);
		Util.wait(2);
		this.saveEvidence("Datos Crédito portafolio");
		this.returnInicio();
		return null;
	}

//***********************************************************************************************************************
	/**
	 * Metodo responsable de realizar la consulta en la opción Integrada por cuenta
	 * retorna en un dato tipo String los datos encontrados en pantala: [ CONSULTA
	 * DE SALDO CUENTA CORRIENTE / CREDIPLUS ]
	 * 
	 * @author Jhon Quiñones Arboleda
	 */
	int index = 0;

	public String consultaSaldoCuenta(String numCuenta) {
		try {
			String filtro = "CONSULTA DE SALDO CUENTA CORRIENTE / CREDIPLUS";
			int intentosMaximos = 3;
			this.numEscapeQInicio = 10;

			this.selectOpcionMenuLista(2);
			Util.wait(1);
			this.enter();
			this.write(numCuenta);
			this.ctrlX(1);
			this.write("1");
			this.ctrlX(1);

			String texto = this.read();

			if (texto.contains(filtro)) {
				Evidence.save("CONSULTA SALDO DE CUENTA", this);
				return texto;
			} else {
				if (index < intentosMaximos) {
					index++;
					Reporter.write(
							"PANTALLA " + filtro + " NO FUE ENCONTRADA. Reintentando el proceso. Intento " + index);
					this.returnInicio();
					return consultaSaldoCuenta(numCuenta);
				} else {
					returnInicio();
					Reporter.write("PROCESO FALLIDO DESPUÉS DE " + intentosMaximos + " INTENTOS.");
					return "No se pudo consultar el saldo después de varios intentos.";
				}
			}
		} catch (Exception e) {
			return "Error: " + e.getMessage();
		}
	}
}
