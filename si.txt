/**
 * Navega al menú y submenús indicados y espera el ingreso del módulo.
 * Mantiene la misma lógica y comportamiento que la implementación original.
 */
public String irAOpcion(String title, String opcMenu, String... opcSubMenu) throws Exception {
    Util.wait(1);

    // Preparar rutas y estado
    String menuXPath = xPathLocMenu.replace("NB_MENU_INICIAL", opcMenu);
    String pathMenu = opcMenu;
    String finalOption = opcMenu;

    WebElement menuElement = this.element(menuXPath);
    if (menuElement == null) {
        Evidence.save("ErrorMenu", this);
        return "No se encontró en el Menú [" + pathMenu + "] - Valide la información";
    }

    // Detectar navegador (solo consulta como antes)
    String navegador = SettingsRun.getTestData().getParameter("Navegador").trim();
    boolean isChrome = navegador.contains("CHROME");

    // Hover sobre el elemento del menú principal (método según navegador)
    if (isChrome) {
        this.mouseOver(menuElement);
    } else {
        dispatchMouseOverByJS(menuElement);
    }

    // Recorrer submenús (si los hay)
    for (int idx = 0; idx < opcSubMenu.length; idx++) {
        Util.wait(1);

        String subOption = opcSubMenu[idx];
        String subXPath = xPathLocSubMenu2.replace("NB_SUBMENU", subOption);
        List<WebElement> found = this.findElements(By.xpath(subXPath));

        // Si hay múltiples coincidencias, usar la variante con espacios (idéntico a original)
        if (found.size() > 1) {
            subXPath = "(" + xPathLocSubMenu.replace("NB_SUBMENU", subOption + "    ") + ")[1]";
            found = this.findElements(By.xpath(subXPath));
        }

        if (found.size() == 0) {
            Evidence.save("ErrorMenu", this);
            return "En el menú [" + pathMenu + "] NO se encontró la opción [" + subOption + "] - Valide la información";
        } else if (found.size() > 1) {
            return "Existen muchos submenús que contienen [" + subOption + "] en el WebPage";
        }

        // Espera hasta que el elemento esté visible (igual que do/while original)
        while (!this.isDisplayed(found.get(0))) {
            Util.wait(1);
        }

        pathMenu += "/" + subOption;
        finalOption = subOption;

        // Mover mouse / click según navegador (conserva comportamiento original)
        if (isChrome) {
            Util.wait(3);
            this.mouseOver(this.element(subXPath));
        } else {
            WebElement elemento = this.element(By.xpath(subXPath));
            dispatchMouseOverByJS(elemento);
            this.getJse().executeScript("arguments[0].click();", elemento);
        }
    }

    // Click final para CHROME (igual que original)
    if (isChrome) {
        this.mouseClick();
    }

    // Estado por defecto
    this.estaEnLogueo = false;

    // Esperar título o retornar a logueo
    if (title != null && !title.isEmpty()) {
        this.waitIngresoModulo(title);
    } else {
        this.retornoALogueo();
    }

    // Si cerró el portal, reintentar el login y repetir la navegación (igual que original)
    if (this.estaEnLogueo) {
        DatosEmpresarial.ESTALOGMIDD_PYM = false;
        this.pageLogin.loginMiddle();
        return this.irAOpcion(title, opcMenu, opcSubMenu);
    }

    Evidence.save("IngresoA_" + finalOption.replace(" ", "_"), this);
    return null;
}

/* Helper privado: despacha el evento mouseover con JS (mismo script que usabas). */
private void dispatchMouseOverByJS(WebElement element) {
    this.getJse().executeScript(
        "var event = new MouseEvent('mouseover', {bubbles: true, cancelable: true, view: window}); arguments[0].dispatchEvent(event);",
        element
    );
}
